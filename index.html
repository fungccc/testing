<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Tuner T1 - Player Suite (v4.0)</title>
    <style>
        :root {
            --bg-color: #121212;
            --text-main: #ffffff;
            --accent-green: #4caf50;
            --accent-red: #ff4444;
            --accent-blue: #448aff; /* New for Playback */
            --panel-bg: #1e1e1e;
            --modal-bg: rgba(0, 0, 0, 0.95);
        }
        body {
            background-color: var(--bg-color);
            color: var(--text-main);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            margin: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }
        
        /* Top Header */
        header {
            display: flex;
            justify-content: space-between;
            padding: 15px;
            align-items: center;
        }
        .settings-btn { cursor: pointer; font-size: 1.5rem; }
        
        /* Action Buttons Area */
        .action-area { display: flex; gap: 8px; }

        .btn {
            border: 1px solid #555;
            background: transparent;
            color: #ccc;
            padding: 5px 12px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.8rem;
            display: flex;
            align-items: center;
            gap: 5px;
            transition: all 0.2s;
            text-decoration: none;
        }
        
        /* Record Button */
        .rec-btn { border-color: var(--accent-red); color: var(--accent-red); }
        .rec-btn.recording { background: var(--accent-red); color: white; animation: pulse 1.5s infinite; }
        
        /* Play/Import Button */
        .play-btn { border-color: var(--accent-blue); color: var(--accent-blue); }
        .play-btn:hover { background: rgba(68, 138, 255, 0.2); }
        .play-btn.playing { background: var(--accent-blue); color: white; }

        .hidden-input { display: none; }

        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }
        
        /* Main Display */
        .readout {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            align-items: center;
            text-align: center;
            padding: 10px 0;
        }
        .hz-val { font-size: 1.2rem; color: #ccc; }
        .hz-label { font-size: 0.7rem; color: #888; display: block; }
        .note-display { font-size: 5rem; font-weight: 300; line-height: 1; }
        .note-octave { font-size: 2rem; }
        .cents-val { font-size: 1.2rem; color: #ccc; }
        
        /* Visualizer */
        .viz-container {
            flex: 1;
            position: relative;
            background: #222;
            margin: 0 10px;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid #333;
        }
        canvas { width: 100%; height: 100%; display: block; }
        .start-btn {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            padding: 15px 30px;
            background: var(--accent-green);
            border: none;
            color: white;
            border-radius: 30px;
            cursor: pointer;
            font-size: 1rem;
            z-index: 10;
        }

        /* Keyboard Footer */
        .keyboard { padding: 10px; background: black; }
        .keys-row { display: flex; justify-content: center; gap: 4px; flex-wrap: wrap; }
        .key {
            width: 35px; height: 45px; background: #333; border-radius: 6px;
            display: flex; align-items: center; justify-content: center;
            font-weight: bold; color: #fff; font-size: 0.9rem; transition: background 0.1s;
        }
        .key.sharp { background: #444; height: 35px; margin-bottom: 10px;}
        .key.active { background: var(--accent-green); color: #000; box-shadow: 0 0 15px var(--accent-green); transform: scale(1.1); }
        /* Playback Active Color (Blue) */
        .key.playback-active { background: var(--accent-blue) !important; color: white !important; box-shadow: 0 0 15px var(--accent-blue); transform: scale(1.1); }

        footer { text-align: center; font-size: 0.7rem; color: #555; padding: 5px; margin-top: auto; }

        /* Modal Styles */
        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: var(--modal-bg); z-index: 100; backdrop-filter: blur(5px); }
        .modal-content { max-width: 600px; margin: 40px auto; padding: 20px; color: white; }
        .close-btn { float: right; font-size: 2rem; cursor: pointer; }
        .mode-options { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 15px; }
        .mode-card { background: #222; border: 2px solid #333; padding: 15px; cursor: pointer; border-radius: 10px; }
        .mode-card.selected { border-color: var(--accent-green); background: #1a331a; }
        .info-table { width: 100%; border-collapse: collapse; margin-top: 20px; font-size: 0.8rem; }
        .info-table th, .info-table td { border: 1px solid #444; padding: 8px; }
    </style>
</head>
<body>

    <header>
        <div class="settings-btn" id="openSettings">‚öôÔ∏è</div>
        <div>Tuner T1</div>
        <div class="action-area">
            <button class="btn rec-btn" id="recordBtn">‚óè ÈåÑË£Ω</button>
            <button class="btn rec-btn" id="exportBtn" style="display:none; border-color:#fff; color:#fff;">‚¨á XML</button>
            
            <input type="file" id="fileInput" class="hidden-input" accept=".musicxml,.xml">
            <button class="btn play-btn" id="importBtn">üìÇ Êí≠Êîæ XML</button>
        </div>
    </header>

    <div class="readout">
        <div><span id="hz" class="hz-val">0.0</span> <span class="hz-label">HERTZ</span></div>
        <div class="note-display"><span id="note">-</span><span id="octave" class="note-octave"></span></div>
        <div><span id="cents" class="cents-val">0.0</span> <span class="hz-label">CENTS</span></div>
    </div>

    <div class="viz-container">
        <button class="start-btn" id="startBtn">ÂïüÂãïÂºïÊìé (Start)</button>
        <canvas id="tunerCanvas"></canvas>
    </div>

    <div class="keyboard">
        <div class="keys-row" style="margin-bottom: -15px; z-index: 2; position: relative;">
            <div class="key sharp" data-note="C#">C#</div><div class="key sharp" data-note="D#">D#</div>
            <div style="width: 35px;"></div>
            <div class="key sharp" data-note="F#">F#</div><div class="key sharp" data-note="G#">G#</div><div class="key sharp" data-note="A#">A#</div>
        </div>
        <div class="keys-row">
            <div class="key" data-note="C">C</div><div class="key" data-note="D">D</div><div class="key" data-note="E">E</div>
            <div class="key" data-note="F">F</div><div class="key" data-note="G">G</div><div class="key" data-note="A">A</div><div class="key" data-note="B">B</div>
        </div>
    </div>
    
    <footer>Ë±êÁãÇÂá∫ÂìÅ ‚Ä¢ Player Suite v4.0</footer>

    <div id="settingsModal" class="modal">
        <div class="modal-content">
            <span class="close-btn" id="closeSettings">&times;</span>
            <h2>DSP Ë®≠ÂÆö</h2>
            <div class="mode-options">
                <div class="mode-card selected" onclick="setMode('standard')" id="modeStandard">
                    <strong>Ê®ôÊ∫ñÊ®°Âºè</strong><br><small>Âêâ‰ªñ/‰∫∫ËÅ≤ (2048 pts)</small>
                </div>
                <div class="mode-card" onclick="setMode('bass')" id="modeBass">
                    <strong>‰ΩéÈü≥Ê®°Âºè</strong><br><small>Ë≤ùÊñØ/ÈãºÁê¥ (4096 pts)</small>
                </div>
            </div>
            <table class="info-table">
                <tr><th>Ê®°Âºè</th><th>ÊúÄ‰ΩéÈ†ªÁéá</th><th>ÂèçÊáâÈÄüÂ∫¶</th></tr>
                <tr><td>Ê®ôÊ∫ñ</td><td>~43Hz</td><td>Ê•µÂø´</td></tr>
                <tr><td>‰ΩéÈü≥</td><td>~21Hz</td><td>Á®çÊÖ¢</td></tr>
            </table>
        </div>
    </div>

    <script>
        // === CORE VARIABLES ===
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let analyser, dataArray;
        let isRunning = false;
        let currentFFTSize = 2048;
        const A4 = 440;
        const notes = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
        
        // UI
        const hzEl = document.getElementById('hz');
        const noteEl = document.getElementById('note');
        const octEl = document.getElementById('octave');
        const centsEl = document.getElementById('cents');
        const canvas = document.getElementById('tunerCanvas');
        const ctx = canvas.getContext('2d');
        const keys = document.querySelectorAll('.key');

        // History
        const historySize = 300; 
        const pitchHistory = new Array(historySize).fill(null);

        // === RECORDER VARIABLES ===
        let isRecording = false;
        let recordedNotes = []; 
        let currentNoteEvent = null; 
        let noteStartTime = 0;
        const MIN_NOTE_DURATION = 100;

        // === INITIALIZATION ===
        document.getElementById('startBtn').onclick = async function() {
            this.style.display = 'none';
            if (audioCtx.state === 'suspended') await audioCtx.resume();
            
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                analyser = audioCtx.createAnalyser();
                setMode('standard'); 
                const source = audioCtx.createMediaStreamSource(stream);
                source.connect(analyser);
                isRunning = true;
                update();
            } catch (e) { alert("Mic Access Required for Tuner"); }
        };

        // Modal Logic
        const modal = document.getElementById('settingsModal');
        document.getElementById('openSettings').onclick = () => modal.style.display = 'block';
        document.getElementById('closeSettings').onclick = () => modal.style.display = 'none';
        window.setMode = (mode) => {
            currentFFTSize = (mode === 'standard') ? 2048 : 4096;
            if (analyser) {
                analyser.fftSize = currentFFTSize;
                dataArray = new Float32Array(analyser.fftSize);
            }
            document.getElementById('modeStandard').className = mode === 'standard' ? 'mode-card selected' : 'mode-card';
            document.getElementById('modeBass').className = mode === 'bass' ? 'mode-card selected' : 'mode-card';
        };

        // === PLAYER / IMPORT LOGIC (NEW IN v4.0) ===
        const fileInput = document.getElementById('fileInput');
        const importBtn = document.getElementById('importBtn');

        importBtn.onclick = () => fileInput.click();

        fileInput.onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                const xmlContent = e.target.result;
                playMusicXML(xmlContent);
            };
            reader.readAsText(file);
            // Reset input so same file can be selected again
            fileInput.value = ''; 
        };

        function playMusicXML(xmlString) {
            if (audioCtx.state === 'suspended') audioCtx.resume();

            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlString, "text/xml");
            const noteNodes = xmlDoc.querySelectorAll("note");
            
            if (noteNodes.length === 0) {
                alert("Invalid or empty MusicXML");
                return;
            }

            importBtn.classList.add('playing');
            importBtn.innerText = "üîä Êí≠Êîæ‰∏≠...";

            let currentTime = audioCtx.currentTime;
            // Small buffer start
            currentTime += 0.1;

            noteNodes.forEach((node) => {
                // Parse XML tags
                const stepNode = node.querySelector("step");
                const octaveNode = node.querySelector("octave");
                const alterNode = node.querySelector("alter");
                const durationNode = node.querySelector("duration");
                const isRest = node.querySelector("rest") !== null;

                if (durationNode) {
                    const durationVal = parseFloat(durationNode.textContent);
                    // Conversion: In our recorder, we saved ms directly. 
                    // So duration 500 = 500ms = 0.5s.
                    // If file is from MuseScore, this mapping might be off (beats), 
                    // but for self-playback it's 1:1.
                    const durationSec = durationVal / 1000; 

                    if (!isRest && stepNode && octaveNode) {
                        let noteName = stepNode.textContent;
                        if (alterNode && alterNode.textContent === "1") noteName += "#";
                        
                        const octave = parseInt(octaveNode.textContent);
                        const freq = getFreq(noteName, octave);
                        
                        // Schedule Sound
                        playTone(freq, currentTime, durationSec);
                        
                        // Schedule UI Highlight (using setTimeout to sync with AudioTime)
                        const delayMs = (currentTime - audioCtx.currentTime) * 1000;
                        setTimeout(() => highlightKey(noteName, true), delayMs);
                        setTimeout(() => highlightKey(noteName, false), delayMs + (durationSec * 1000));
                        
                        // Show on Note Display
                        setTimeout(() => {
                             hzEl.innerText = freq.toFixed(1);
                             noteEl.innerText = noteName;
                             octEl.innerText = octave;
                        }, delayMs);
                    }
                    currentTime += durationSec;
                }
            });

            // Reset UI after song
            const totalTimeMs = (currentTime - audioCtx.currentTime) * 1000;
            setTimeout(() => {
                importBtn.classList.remove('playing');
                importBtn.innerText = "üìÇ Êí≠Êîæ XML";
            }, totalTimeMs);
        }

        function playTone(freq, startTime, duration) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            
            osc.type = 'sine';
            osc.frequency.value = freq;
            
            // Envelope to avoid clicking
            gain.gain.setValueAtTime(0, startTime);
            gain.gain.linearRampToValueAtTime(0.5, startTime + 0.05); // Attack
            gain.gain.linearRampToValueAtTime(0, startTime + duration); // Release

            osc.connect(gain);
            gain.connect(audioCtx.destination);
            
            osc.start(startTime);
            osc.stop(startTime + duration);
        }

        function getFreq(note, octave) {
            const allNotes = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
            const semitones = allNotes.indexOf(note);
            // MIDI note calculation: (Octave + 1) * 12 + semitones
            const midi = (octave + 1) * 12 + semitones;
            return 440 * Math.pow(2, (midi - 69) / 12);
        }

        function highlightKey(note, active) {
            // Remove 'playback-active' from all first to be safe (monophonic visual)
            if (active) {
                keys.forEach(k => k.classList.remove('playback-active'));
                const k = document.querySelector(`.key[data-note="${note}"]`);
                if(k) k.classList.add('playback-active');
            } else {
                const k = document.querySelector(`.key[data-note="${note}"]`);
                if(k) k.classList.remove('playback-active');
            }
        }

        // === RECORDER & EXPORT LOGIC ===
        const recBtn = document.getElementById('recordBtn');
        const exportBtn = document.getElementById('exportBtn');

        recBtn.onclick = () => {
            isRecording = !isRecording;
            if (isRecording) {
                recordedNotes = [];
                currentNoteEvent = null;
                recBtn.innerText = "‚ñ† ÂÅúÊ≠¢";
                recBtn.classList.add('recording');
                exportBtn.style.display = 'none';
            } else {
                finishCurrentNote();
                recBtn.innerText = "‚óè ÈåÑË£Ω";
                recBtn.classList.remove('recording');
                if (recordedNotes.length > 0) exportBtn.style.display = 'block';
            }
        };

        exportBtn.onclick = () => {
            const xmlContent = generateMusicXML(recordedNotes);
            const blob = new Blob([xmlContent], { type: 'application/vnd.recordare.musicxml+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `recording_${new Date().toISOString().slice(0,19)}.musicxml`;
            a.click();
        };

        // === DSP & LOOP (Original Tuner Logic) ===
        function detectPitchYIN(buffer, sampleRate) {
            const threshold = 0.10;
            const halfSize = Math.floor(buffer.length / 2);
            const yinBuffer = new Float32Array(halfSize);
            for (let t = 0; t < halfSize; t++) {
                let sum = 0;
                for (let i = 0; i < halfSize; i+=2) {
                    const d = buffer[i] - buffer[i + t];
                    sum += d * d;
                }
                yinBuffer[t] = sum;
            }
            yinBuffer[0] = 1;
            let runningSum = 0;
            for (let t = 1; t < halfSize; t++) {
                runningSum += yinBuffer[t];
                yinBuffer[t] *= t / runningSum;
            }
            let tau = -1;
            for (let t = 2; t < halfSize; t++) {
                if (yinBuffer[t] < threshold) {
                    while (t + 1 < halfSize && yinBuffer[t + 1] < yinBuffer[t]) t++;
                    tau = t;
                    break;
                }
            }
            if (tau === -1) return -1;
            const x0 = yinBuffer[tau - 1], x2 = yinBuffer[tau + 1], x1 = yinBuffer[tau];
            return sampleRate / (tau + (x2 - x0) / (2 * (2 * x1 - x2 - x0)));
        }

        function update() {
            if (!isRunning) return;
            analyser.getFloatTimeDomainData(dataArray);
            
            let rms = 0;
            for (let i=0; i<dataArray.length; i+=4) rms += dataArray[i]*dataArray[i];
            rms = Math.sqrt(rms / (dataArray.length/4));

            let cents = null;
            let detectedNote = null;
            let detectedOctave = null;

            if (rms > 0.01) {
                const pitch = detectPitchYIN(dataArray, audioCtx.sampleRate);
                const minFreq = currentFFTSize === 4096 ? 20 : 40;

                if (pitch !== -1 && pitch > minFreq && pitch < 4200) {
                    const noteNum = 12 * (Math.log(pitch / A4) / Math.log(2));
                    const roundedNote = Math.round(noteNum) + 69;
                    detectedNote = notes[roundedNote % 12];
                    detectedOctave = Math.floor(roundedNote / 12) - 1;
                    
                    const freqFromNote = A4 * Math.pow(2, (roundedNote - 69) / 12);
                    cents = Math.floor(1200 * Math.log(pitch / freqFromNote) / Math.log(2));

                    hzEl.innerText = pitch.toFixed(1);
                    noteEl.innerText = detectedNote;
                    octEl.innerText = detectedOctave;
                    centsEl.innerText = (cents > 0 ? "+" : "") + cents;
                    centsEl.style.color = Math.abs(cents) < 5 ? "#4caf50" : "#ccc";
                    
                    // Only update visual keyboard if NOT currently playing back XML
                    if (!importBtn.classList.contains('playing')) {
                        keys.forEach(k => k.classList.remove('active'));
                        const k = document.querySelector(`.key[data-note="${detectedNote}"]`);
                        if(k) k.classList.add('active');
                    }
                }
            }

            if (isRecording) processRecording(detectedNote, detectedOctave);

            pitchHistory.pop();
            pitchHistory.unshift(cents);
            drawVisualizer();
            requestAnimationFrame(update);
        }

        function processRecording(note, octave) {
            const now = Date.now();
            if (currentNoteEvent && note === currentNoteEvent.note && octave === currentNoteEvent.octave) {
                // holding
            } else {
                if (currentNoteEvent) {
                    const duration = now - noteStartTime;
                    if (duration > MIN_NOTE_DURATION) {
                        recordedNotes.push({ ...currentNoteEvent, duration });
                    }
                }
                if (note) {
                    currentNoteEvent = { note, octave };
                    noteStartTime = now;
                } else {
                    currentNoteEvent = null;
                }
            }
        }

        function finishCurrentNote() {
            if (currentNoteEvent && isRecording) {
                const duration = Date.now() - noteStartTime;
                if (duration > MIN_NOTE_DURATION) recordedNotes.push({ ...currentNoteEvent, duration });
                currentNoteEvent = null;
            }
        }

        function generateMusicXML(notesData) {
            let xml = `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE score-partwise PUBLIC "-//Recordare//DTD MusicXML 4.0 Partwise//EN" "http://www.musicxml.org/dtds/partwise.dtd">
<score-partwise version="4.0">
  <part-list><score-part id="P1"><part-name>Audio Recording</part-name></score-part></part-list>
  <part id="P1"><measure number="1"><attributes><divisions>1000</divisions></attributes>`;
            notesData.forEach(n => {
                const step = n.note.charAt(0);
                const alter = n.note.includes('#') ? 1 : 0;
                xml += `<note><pitch><step>${step}</step>${alter ? '<alter>1</alter>' : ''}<octave>${n.octave}</octave></pitch><duration>${n.duration}</duration><type>whole</type></note>`;
            });
            xml += `</measure></part></score-partwise>`;
            return xml;
        }

        function drawVisualizer() {
            canvas.width = canvas.parentElement.clientWidth;
            canvas.height = canvas.parentElement.clientHeight;
            const w = canvas.width, h = canvas.height;
            const centerW = w * 0.15;
            
            ctx.fillStyle = "#e66a4e"; ctx.fillRect(0,0,w,h); 
            ctx.fillStyle = "#3e8e41"; ctx.fillRect(w/2 - centerW/2, 0, centerW, h); 
            ctx.fillStyle = "#111"; ctx.fillRect(w/2 + centerW/2, 0, w, h); 
            
            ctx.strokeStyle = "#fff"; ctx.lineWidth = 3; ctx.beginPath();
            const rowH = h / historySize;
            for(let i=0; i<historySize; i++) {
                if(pitchHistory[i] !== null) {
                    const val = Math.max(-50, Math.min(50, pitchHistory[i]));
                    const x = (val + 50) / 100 * w;
                    const y = i * rowH;
                    if(i===0 || pitchHistory[i-1]===null) ctx.moveTo(x,y); else ctx.lineTo(x,y);
                }
            }
            ctx.stroke();
        }
    </script>
</body>
</html>
