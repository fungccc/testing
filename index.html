<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Web Tuner T1 - v6.4 Perfect Harmony</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <style>
        :root {
            --bg-color: #000000;
            --text-main: #ffffff;
            --accent-green: #66cc66;
            --accent-red: #ff5252;
            --accent-blue: #2979ff;
            --accent-yellow: #ffd700;
        }
        body {
            background-color: var(--bg-color);
            color: var(--text-main);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            margin: 0; display: flex; flex-direction: column; height: 100vh; overflow: hidden;
            user-select: none; -webkit-user-select: none; touch-action: manipulation;
        }
        
        header {
            display: flex; justify-content: space-between; padding: 15px; align-items: center;
            background: #000; z-index: 20;
        }
        .settings-btn { cursor: pointer; font-size: 1.5rem; }
        .action-area { display: flex; gap: 8px; }
        .btn {
            border: 1px solid #555; background: transparent; color: #ccc;
            padding: 6px 14px; border-radius: 6px; cursor: pointer; font-size: 0.85rem;
            display: flex; align-items: center; gap: 5px; font-weight: 600; min-width: 80px; justify-content: center;
        }
        .rec-btn.recording { background: var(--accent-red); color: white; border-color: var(--accent-red); animation: pulse 2s infinite; }
        .play-btn { color: var(--accent-blue); border-color: var(--accent-blue); }
        .play-btn.playing { background: var(--accent-red); color: white; border-color: var(--accent-red); }

        .hidden-input { display: none; }
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.7; } 100% { opacity: 1; } }

        .readout {
            display: grid; grid-template-columns: 1fr auto 1fr; align-items: center;
            text-align: center; padding: 10px 0; background: #000; z-index: 20;
        }
        .hz-val { font-size: 1.4rem; color: #888; font-family: monospace; }
        .hz-label { font-size: 0.6rem; color: #555; display: block; letter-spacing: 1px; }
        .note-container { display: flex; align-items: baseline; justify-content: center; width: 140px;}
        .note-display { font-size: 6rem; font-weight: 700; line-height: 1; color: #fff; }
        .note-octave { font-size: 2.5rem; color: #aaa; margin-left: 5px;}
        .cents-val { font-size: 1.4rem; color: #888; font-family: monospace; }
        
        .target-mode-active .note-display { color: var(--accent-yellow); text-shadow: 0 0 10px rgba(255, 215, 0, 0.3); }

        .viz-container { flex: 1; position: relative; background: #000; overflow: hidden; }
        canvas { width: 100%; height: 100%; display: block; }
        
        .start-btn {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            padding: 15px 40px; background: var(--accent-green); border: none;
            color: #000; font-weight: bold; border-radius: 40px; cursor: pointer;
            font-size: 1.2rem; z-index: 30; box-shadow: 0 0 20px rgba(102, 204, 102, 0.4);
        }

        .keyboard-area { background: #000; padding: 10px 0; z-index: 20; border-top: 1px solid #222; }
        
        .octave-scroller {
            display: flex; overflow-x: auto; white-space: nowrap; gap: 10px;
            padding: 5px 15px 15px 15px; margin-bottom: 5px;
            -webkit-overflow-scrolling: touch; scrollbar-width: none;
        }
        .octave-scroller::-webkit-scrollbar { display: none; }

        .pill { 
            background: #222; color: #888; padding: 8px 18px; border-radius: 20px; 
            font-size: 0.85rem; cursor: pointer; transition: all 0.2s; border: 1px solid #333;
            flex-shrink: 0;
        }
        .pill.active { background: #444; color: #fff; border-color: var(--accent-blue); font-weight: bold; box-shadow: 0 0 10px rgba(41, 121, 255, 0.3); }

        .keys-wrapper { padding: 0 5px; }
        .keys-row { display: flex; justify-content: center; gap: 6px; flex-wrap: wrap; }
        .key {
            width: 40px; height: 55px; background: #222; border-radius: 0 0 4px 4px;
            display: flex; align-items: flex-end; justify-content: center;
            font-weight: bold; color: #fff; font-size: 1rem; padding-bottom: 5px;
            cursor: pointer; position: relative; -webkit-tap-highlight-color: transparent;
        }
        .key.sharp { 
            background: #333; height: 35px; margin-bottom: 20px; 
            border-radius: 0 0 4px 4px; z-index: 2; align-items: center; padding-bottom: 0;
        }
        .key.active { background: var(--accent-green) !important; color: #000 !important; transform: translateY(2px); box-shadow: 0 0 15px var(--accent-green); }
        .key.pressed { background: var(--accent-blue) !important; color: #fff !important; transform: translateY(4px); box-shadow: 0 0 10px var(--accent-blue); }

        footer { text-align: center; font-size: 0.7rem; color: #444; padding: 8px; background: #000; }

        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 100; overflow-y: auto; }
        .modal-content { max-width: 500px; margin: 40px auto; padding: 25px; background: #1a1a1a; border-radius: 12px; border: 1px solid #333; }
        .close-btn { float: right; font-size: 1.5rem; cursor: pointer; color: #888; }
        .mode-options { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 20px; }
        .mode-card { background: #222; border: 2px solid #333; padding: 15px; cursor: pointer; border-radius: 8px; }
        .mode-card.selected { border-color: var(--accent-green); background: rgba(102, 204, 102, 0.1); }

        .setting-group { margin-top: 25px; border-top: 1px solid #333; padding-top: 15px; }
        .setting-label { display: flex; justify-content: space-between; color: #ccc; margin-bottom: 5px; font-size: 0.9rem; }
        .setting-val { color: var(--accent-blue); font-family: monospace; }
        .slider-container { display: flex; align-items: center; gap: 15px; margin-top: 10px; }
        input[type=range] { flex: 1; height: 6px; background: #333; border-radius: 3px; outline: none; -webkit-appearance: none; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; width: 20px; height: 20px; background: var(--accent-blue); border-radius: 50%; cursor: pointer; }
        
        .toggle-switch { display: flex; align-items: center; gap: 10px; cursor: pointer; margin-top: 10px; }
        .toggle-switch input { display: none; }
        .slider { width: 40px; height: 20px; background: #333; border-radius: 20px; position: relative; transition: 0.2s; }
        .slider:before { content: ""; position: absolute; width: 16px; height: 16px; left: 2px; bottom: 2px; background: #888; border-radius: 50%; transition: 0.2s; }
        input:checked + .slider { background: var(--accent-yellow); }
        input:checked + .slider:before { transform: translateX(20px); background: #000; }
        
        .preset-btn-group { display: flex; gap: 8px; margin-top: 10px; flex-wrap: wrap; }
        .preset-btn { 
            background: #222; border: 1px solid #444; color: #ccc; padding: 5px 12px; 
            border-radius: 15px; cursor: pointer; font-size: 0.8rem; 
        }
        .preset-btn:hover { border-color: #888; }
        
        select.dark-select {
            background: #222; color: #fff; border: 1px solid #444; padding: 8px; 
            border-radius: 6px; width: 100%; margin-top: 10px;
        }
        select.dark-select:disabled { opacity: 0.5; cursor: not-allowed; }

    </style>
</head>
<body id="appBody">

    <header>
        <div class="settings-btn" id="openSettings">‚öôÔ∏è</div>
        <div style="font-weight:900; letter-spacing:1px; color:#fff;">TUNER <span style="color:var(--accent-green)">T1</span></div>
        <div class="action-area">
            <button class="btn rec-btn" id="recordBtn">‚óè REC</button>
            <button class="btn rec-btn" id="exportBtn" style="display:none; border-color:#fff; color:#fff;">‚¨á XML</button>
            <input type="file" id="fileInput" class="hidden-input" accept="*">
            <button class="btn play-btn" id="importBtn">‚ñ∂ PLAY</button>
        </div>
    </header>

    <div class="readout">
        <div><span id="hz" class="hz-val">0.0</span> <span class="hz-label">HZ</span></div>
        <div class="note-container"><span id="note" class="note-display">-</span><span id="octave" class="note-octave"></span></div>
        <div><span id="cents" class="cents-val">0.0</span> <span class="hz-label">CENTS</span></div>
    </div>

    <div class="viz-container">
        <button class="start-btn" id="startBtn">‚ö° ÂïüÂãï (Start)</button>
        <canvas id="tunerCanvas"></canvas>
    </div>

    <div class="keyboard-area">
        <div class="octave-scroller" id="octaveScroller">
            <div class="pill" data-oct="1">-3 (C1)</div>
            <div class="pill" data-oct="2">-2 (C2)</div>
            <div class="pill" data-oct="3">-1 (C3)</div>
            <div class="pill active" data-oct="4">Default (C4)</div>
            <div class="pill" data-oct="5">+1 (C5)</div>
            <div class="pill" data-oct="6">+2 (C6)</div>
            <div class="pill" data-oct="7">+3 (C7)</div>
        </div>

        <div class="keys-wrapper">
            <div class="keys-row" style="margin-bottom: -20px; padding-left: 20px;">
                <div class="key sharp" data-note="C#">C#</div><div class="key sharp" data-note="D#">D#</div>
                <div style="width: 46px; pointer-events: none;"></div>
                <div class="key sharp" data-note="F#">F#</div><div class="key sharp" data-note="G#">G#</div><div class="key sharp" data-note="A#">A#</div>
            </div>
            <div class="keys-row">
                <div class="key" data-note="C">C</div><div class="key" data-note="D">D</div><div class="key" data-note="E">E</div>
                <div class="key" data-note="F">F</div><div class="key" data-note="G">G</div><div class="key" data-note="A">A</div><div class="key" data-note="B">B</div>
            </div>
        </div>
    </div>
    
    <footer>Ë±êÁãÇÂá∫ÂìÅ ‚Ä¢ v6.4 Perfect Harmony</footer>

    <div id="settingsModal" class="modal">
        <div class="modal-content">
            <span class="close-btn" id="closeSettings">&times;</span>
            <h2 style="color:white; margin-top:0;">Ë®≠ÂÆö (Settings)</h2>
            <div class="mode-options">
                <div class="mode-card selected" onclick="setMode('turbo')" id="modeTurbo">
                    <strong style="color:#fff">üéπ Ê•µÈÄüÊ®°Âºè</strong><br><small style="color:#888">‰∏ÄËà¨‰ΩøÁî® (ÈùàÊïè)</small>
                </div>
                <div class="mode-card" onclick="setMode('bass')" id="modeBass">
                    <strong style="color:#fff">üê¢ ‰ΩéÈü≥Ê®°Âºè</strong><br><small style="color:#888">Ë≤ùÊñØ/‰ΩéÈ†ªÂ∞àÁî®</small>
                </div>
            </div>
            <div class="setting-group">
                <div class="setting-label">üîä ÁôºËÅ≤ÈÉ®Èü≥Èáè (Tone Volume) <span id="volValueDisplay" class="setting-val">150%</span></div>
                <div class="slider-container">
                    <span style="font-size:1.2rem;">üîà</span>
                    <input type="range" id="volSlider" min="0.1" max="2.0" step="0.1" value="1.5">
                    <span style="font-size:1.2rem;">üîä</span>
                </div>
            </div>
            <div class="setting-group">
                <div class="setting-label">üéπ A4 Âü∫Ê∫ñÈü≥ (Concert Pitch) <span id="a4Display" class="setting-val">440 Hz</span></div>
                <div class="slider-container">
                    <span style="color:#888; font-size:0.8rem;">430</span>
                    <input type="range" id="a4Slider" min="430" max="450" step="1" value="440">
                    <span style="color:#888; font-size:0.8rem;">450</span>
                </div>
            </div>
            <div class="setting-group">
                <div class="setting-label">üéØ ÁõÆÊ®ôÈü≥ÈéñÂÆö (Target Mode)</div>
                <label class="toggle-switch">
                    <input type="checkbox" id="targetModeToggle">
                    <div class="slider"></div>
                    <span style="font-size:0.8rem; color:#ccc;">ÂïüÁî®ÈéñÂÆö (Lock)</span>
                </label>
                <select id="targetNoteSelect" class="dark-select" disabled></select>
                <div class="setting-label" style="margin-top:10px; font-size:0.8rem;">Ê®ÇÂô® Preset (Âø´ÈÄüË®≠ÂÆö):</div>
                <div class="preset-btn-group">
                    <button class="preset-btn" onclick="applyPreset('guitar')">üé∏ Guitar</button>
                    <button class="preset-btn" onclick="applyPreset('bass')">üé∏ Bass</button>
                    <button class="preset-btn" onclick="applyPreset('ukulele')">Ukulele</button>
                    <button class="preset-btn" onclick="applyPreset('violin')">Violin</button>
                </div>
            </div>
            <div class="setting-group">
                <div class="setting-label">üö™ Âô™Èü≥ÈñÄÊ™ª (Noise Gate) <span id="gateDisplay" class="setting-val">Low</span></div>
                <div class="slider-container">
                    <span style="font-size:0.8rem;">ÈùàÊïè</span>
                    <input type="range" id="gateSlider" min="0.001" max="0.05" step="0.001" value="0.003">
                    <span style="font-size:0.8rem;">ÊäóÂô™</span>
                </div>
            </div>
            <div class="setting-group">
                <div class="setting-label">üåä Á©©ÂÆöÂ∫¶ (Stability) <span id="smoothDisplay" class="setting-val">Balanced</span></div>
                <div class="slider-container">
                    <span style="font-size:0.8rem;">Âø´ÈÄü</span>
                    <input type="range" id="smoothSlider" min="0.1" max="0.9" step="0.1" value="0.3">
                    <span style="font-size:0.8rem;">Âπ≥Êªë</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)({ latencyHint: 'interactive' });
        let analyser, micSource, gainNode, dataArray, mediaStream;
        let toneOsc = null, toneGain = null;
        let isRunning = false;
        let currentFFTSize = 2048; 
        let downsampleStep = 2;
        
        const defaultSettings = {
            a4: 440, gate: 0.003, smoothing: 0.3, targetMode: false, targetNoteIndex: 69 
        };
        let appSettings = { ...defaultSettings };
        const saved = localStorage.getItem('tuner_v6_settings');
        if (saved) { try { appSettings = { ...defaultSettings, ...JSON.parse(saved) }; } catch(e){} }
        function saveSettings() { localStorage.setItem('tuner_v6_settings', JSON.stringify(appSettings)); }

        let keyboardOctave = 4;
        let masterVolume = 1.5;
        const notes = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
        
        const ui = {
            hz: document.getElementById('hz'),
            note: document.getElementById('note'),
            oct: document.getElementById('octave'),
            cents: document.getElementById('cents'),
            keys: document.querySelectorAll('.key'),
            recBtn: document.getElementById('recordBtn'),
            exportBtn: document.getElementById('exportBtn'),
            importBtn: document.getElementById('importBtn'),
            startBtn: document.getElementById('startBtn'),
            octavePills: document.querySelectorAll('.pill[data-oct]'),
            volSlider: document.getElementById('volSlider'),
            volDisplay: document.getElementById('volValueDisplay'),
            a4Slider: document.getElementById('a4Slider'),
            a4Display: document.getElementById('a4Display'),
            gateSlider: document.getElementById('gateSlider'),
            gateDisplay: document.getElementById('gateDisplay'),
            smoothSlider: document.getElementById('smoothSlider'),
            smoothDisplay: document.getElementById('smoothDisplay'),
            targetToggle: document.getElementById('targetModeToggle'),
            targetSelect: document.getElementById('targetNoteSelect'),
            appBody: document.getElementById('appBody')
        };
        const canvas = document.getElementById('tunerCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });

        const historySize = 300; 
        const pitchHistory = new Array(historySize).fill(null);
        let lastNoteName = "";
        let currentCents = 0; 
        let isSignalActive = false;
        let lastValidCents = 0;
        let framesSinceLastSignal = 0;
        const SIGNAL_HOLD_FRAMES = 12; 
        let smoothedCents = 0;

        // === SETUP ===
        function initTargetSelect() {
            ui.targetSelect.innerHTML = "";
            for (let i = 24; i <= 107; i++) { 
                const noteName = notes[i % 12];
                const oct = Math.floor(i / 12) - 1;
                const opt = document.createElement('option');
                opt.value = i;
                opt.text = `${noteName}${oct}`;
                ui.targetSelect.appendChild(opt);
            }
        }
        initTargetSelect();

        function applyUI() {
            ui.a4Slider.value = appSettings.a4;
            ui.a4Display.innerText = appSettings.a4 + " Hz";
            ui.gateSlider.value = appSettings.gate;
            ui.gateDisplay.innerText = (appSettings.gate * 1000).toFixed(1);
            ui.smoothSlider.value = appSettings.smoothing;
            ui.smoothDisplay.innerText = Math.round(appSettings.smoothing * 100) + "%";
            ui.targetToggle.checked = appSettings.targetMode;
            ui.targetSelect.disabled = !appSettings.targetMode;
            ui.targetSelect.value = appSettings.targetNoteIndex;
            if (appSettings.targetMode) ui.appBody.classList.add('target-mode-active');
            else ui.appBody.classList.remove('target-mode-active');
        }
        applyUI();

        ui.a4Slider.addEventListener('input', function() { appSettings.a4 = parseInt(this.value); ui.a4Display.innerText = appSettings.a4 + " Hz"; saveSettings(); });
        ui.gateSlider.addEventListener('input', function() { appSettings.gate = parseFloat(this.value); ui.gateDisplay.innerText = (appSettings.gate * 1000).toFixed(1); saveSettings(); });
        ui.smoothSlider.addEventListener('input', function() { appSettings.smoothing = parseFloat(this.value); ui.smoothDisplay.innerText = Math.round(appSettings.smoothing * 100) + "%"; saveSettings(); });
        ui.targetToggle.addEventListener('change', function() { appSettings.targetMode = this.checked; ui.targetSelect.disabled = !this.checked; if (this.checked) ui.appBody.classList.add('target-mode-active'); else ui.appBody.classList.remove('target-mode-active'); saveSettings(); });
        ui.targetSelect.addEventListener('change', function() { appSettings.targetNoteIndex = parseInt(this.value); saveSettings(); });
        window.applyPreset = (inst) => {
            let startNote = 69; 
            if (inst === 'guitar') startNote = 40; if (inst === 'bass') startNote = 28; 
            if (inst === 'ukulele') startNote = 69; if (inst === 'violin') startNote = 69; 
            appSettings.targetNoteIndex = startNote; appSettings.targetMode = true; 
            ui.targetToggle.checked = true; applyUI(); saveSettings();
        };

        ui.startBtn.onclick = async function() {
            this.style.display = 'none';
            if (audioCtx.state === 'suspended') await audioCtx.resume();
            try {
                mediaStream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false } });
                analyser = audioCtx.createAnalyser(); analyser.smoothingTimeConstant = 0.8;
                gainNode = audioCtx.createGain(); gainNode.gain.value = 5.0; 
                micSource = audioCtx.createMediaStreamSource(mediaStream); micSource.connect(gainNode); gainNode.connect(analyser); 
                setMode('turbo'); isRunning = true; update();
            } catch (e) { alert("Mic Error: " + e.message); this.style.display = 'block'; }
        };

        // Lifecycle Management
        function stopMic() {
            if (mediaStream) {
                mediaStream.getTracks().forEach(track => track.stop());
                mediaStream = null;
            }
            isRunning = false;
            ui.startBtn.style.display = 'block'; 
            ui.startBtn.innerText = "‚ö° ÈáçÊñ∞ÂïüÂãï (Resume)";
        }
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) { stopMic(); playbackManager.stop(); }
        });

        ui.octavePills.forEach(pill => {
            pill.addEventListener('click', function() {
                ui.octavePills.forEach(p => p.classList.remove('active')); this.classList.add('active');
                keyboardOctave = parseInt(this.getAttribute('data-oct'));
                this.scrollIntoView({behavior: "smooth", block: "nearest", inline: "center"});
            });
        });
        ui.volSlider.addEventListener('input', function() {
            masterVolume = parseFloat(this.value); ui.volDisplay.textContent = Math.round(masterVolume * 100) + "%";
            if (toneGain) toneGain.gain.setTargetAtTime(masterVolume, audioCtx.currentTime, 0.1);
        });

        function startTone(noteName) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const semitones = notes.indexOf(noteName); const noteNum = (keyboardOctave + 1) * 12 + semitones;
            const freq = appSettings.a4 * Math.pow(2, (noteNum - 69) / 12);
            if (toneOsc) stopTone();
            toneOsc = audioCtx.createOscillator(); toneGain = audioCtx.createGain();
            toneOsc.type = 'sine'; toneOsc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            toneGain.gain.setValueAtTime(0, audioCtx.currentTime); toneGain.gain.linearRampToValueAtTime(masterVolume, audioCtx.currentTime + 0.05);
            toneGain.connect(audioCtx.destination); if (analyser) toneGain.connect(analyser); 
            toneOsc.connect(toneGain); toneOsc.start();
        }
        function stopTone() {
            if (toneOsc && toneGain) {
                const stopTime = audioCtx.currentTime + 0.1;
                toneGain.gain.cancelScheduledValues(audioCtx.currentTime); toneGain.gain.setValueAtTime(toneGain.gain.value, audioCtx.currentTime); toneGain.gain.linearRampToValueAtTime(0, stopTime);
                toneOsc.stop(stopTime);
                const oldOsc = toneOsc; const oldGain = toneGain; setTimeout(() => { oldOsc.disconnect(); oldGain.disconnect(); }, 200); toneOsc = null; toneGain = null;
            }
        }
        ui.keys.forEach(key => {
            const note = key.getAttribute('data-note');
            const press = (e) => { e.preventDefault(); key.classList.add('pressed'); startTone(note); };
            const release = (e) => { e.preventDefault(); key.classList.remove('pressed'); stopTone(); };
            key.addEventListener('mousedown', press); key.addEventListener('mouseup', release); key.addEventListener('mouseleave', release); key.addEventListener('touchstart', press); key.addEventListener('touchend', release);
        });

        window.setMode = (mode) => {
            if (mode === 'turbo') { currentFFTSize = 2048; downsampleStep = 2; document.getElementById('modeTurbo').className = 'mode-card selected'; document.getElementById('modeBass').className = 'mode-card'; }
            else { currentFFTSize = 4096; downsampleStep = 2; document.getElementById('modeTurbo').className = 'mode-card'; document.getElementById('modeBass').className = 'mode-card selected'; }
            if (analyser) { analyser.fftSize = currentFFTSize; dataArray = new Float32Array(analyser.fftSize); }
        };
        const modal = document.getElementById('settingsModal');
        document.getElementById('openSettings').onclick = () => modal.style.display = 'block';
        document.getElementById('closeSettings').onclick = () => modal.style.display = 'none';

        function detectPitch(buffer, sampleRate) {
            const threshold = 0.15; const halfSize = Math.floor(buffer.length / 2); const yinBuffer = new Float32Array(halfSize);
            for (let t = 0; t < halfSize; t++) {
                let sum = 0;
                for (let i = 0; i < halfSize; i += downsampleStep) { const d = buffer[i] - buffer[i + t]; sum += d * d; }
                yinBuffer[t] = sum;
            }
            yinBuffer[0] = 1; let runningSum = 0;
            for (let t = 1; t < halfSize; t++) { runningSum += yinBuffer[t]; yinBuffer[t] *= t / runningSum; }
            let tau = -1;
            for (let t = 2; t < halfSize; t++) {
                if (yinBuffer[t] < threshold) { while (t + 1 < halfSize && yinBuffer[t + 1] < yinBuffer[t]) t++; tau = t; break; }
            }
            if (tau === -1) return -1;
            const x0 = yinBuffer[tau - 1], x2 = yinBuffer[tau + 1], x1 = yinBuffer[tau];
            return sampleRate / (tau + (x2 - x0) / (2 * (2 * x1 - x2 - x0)));
        }

        function update() {
            if (!isRunning) return;
            if (!analyser) return; 
            analyser.getFloatTimeDomainData(dataArray);
            let sum = 0; for (let i = 0; i < dataArray.length; i+=4) sum += dataArray[i] * dataArray[i];
            const rms = Math.sqrt(sum / (dataArray.length/4));

            let cents = null; let detectedNote = null; let detectedOctave = null; let hasValidSignal = false;

            if (rms > appSettings.gate) {
                const pitch = detectPitch(dataArray, audioCtx.sampleRate);
                const minFreq = currentFFTSize === 4096 ? 25 : 50;

                if (pitch !== -1 && pitch > minFreq && pitch < 4200) {
                    hasValidSignal = true;
                    const A4 = appSettings.a4;
                    const noteNumFloat = 12 * (Math.log(pitch / A4) / Math.log(2));
                    let roundedNote = Math.round(noteNumFloat) + 69;
                    if (appSettings.targetMode) roundedNote = appSettings.targetNoteIndex;
                    
                    detectedNote = notes[roundedNote % 12]; detectedOctave = Math.floor(roundedNote / 12) - 1;
                    const freqFromNote = A4 * Math.pow(2, (roundedNote - 69) / 12);
                    const rawCents = Math.floor(1200 * Math.log(pitch / freqFromNote) / Math.log(2));
                    smoothedCents = (smoothedCents * appSettings.smoothing) + (rawCents * (1 - appSettings.smoothing));
                    cents = smoothedCents;

                    lastValidCents = cents; framesSinceLastSignal = 0; currentCents = cents; isSignalActive = true;
                    ui.hz.textContent = pitch.toFixed(1); ui.cents.textContent = (cents > 0 ? "+" : "") + cents.toFixed(0);
                    
                    if (lastNoteName !== detectedNote + detectedOctave) {
                        ui.note.textContent = detectedNote; ui.oct.textContent = detectedOctave;
                        lastNoteName = detectedNote + detectedOctave;
                        ui.keys.forEach(k => k.classList.remove('active'));
                        const k = document.querySelector(`.key[data-note="${detectedNote}"]`); if(k) k.classList.add('active');
                    }
                }
            }
            if (!hasValidSignal) {
                framesSinceLastSignal++;
                if (framesSinceLastSignal < SIGNAL_HOLD_FRAMES) { cents = lastValidCents; isSignalActive = true; } 
                else { isSignalActive = false; cents = null; }
            }
            if (isRecording) processRecording(detectedNote, detectedOctave);
            pitchHistory.pop(); pitchHistory.unshift(cents);
            drawVisualizer();
            requestAnimationFrame(update);
        }

        function drawVisualizer() {
            const w = canvas.parentElement.clientWidth; const h = canvas.parentElement.clientHeight; canvas.width = w; canvas.height = h;
            const isLocked = isSignalActive && currentCents !== null && Math.abs(currentCents) <= 5;
            if (isLocked) {
                ctx.fillStyle = "#66cc66"; ctx.fillRect(0, 0, w, h); ctx.strokeStyle = "rgba(255,255,255,0.8)"; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(w/2, 0); ctx.lineTo(w/2, h); ctx.stroke();
            } else {
                const centerW = w * 0.15; ctx.fillStyle = "#ff5252"; ctx.fillRect(0, 0, w/2 - centerW/2, h); ctx.fillStyle = "#66cc66"; ctx.fillRect(w/2 - centerW/2, 0, centerW, h); ctx.fillStyle = "#ff5252"; ctx.fillRect(w/2 + centerW/2, 0, w, h); ctx.strokeStyle = "rgba(255,255,255,0.3)"; ctx.beginPath(); ctx.moveTo(w/2, 0); ctx.lineTo(w/2, h); ctx.stroke();
            }
            ctx.strokeStyle = "#ffffff"; ctx.lineWidth = 4; ctx.lineCap = "round"; ctx.lineJoin = "round"; ctx.beginPath();
            const rowH = h / historySize; let lastX = null;
            for (let i = 0; i < historySize; i++) {
                if (pitchHistory[i] !== null) {
                    const val = Math.max(-50, Math.min(50, pitchHistory[i])); const x = (val + 50) / 100 * w; const y = i * rowH;
                    if (lastX === null) ctx.moveTo(x, y); else if (Math.abs(x - lastX) < w * 0.8) ctx.lineTo(x, y); else ctx.moveTo(x, y);
                    lastX = x;
                } else lastX = null;
            }
            ctx.stroke();
        }

        let isRecording = false; let recordedNotes = []; let currentNoteEvent = null; let noteStartTime = 0;
        
        ui.recBtn.onclick = () => {
            isRecording = !isRecording;
            if (isRecording) {
                recordedNotes = []; currentNoteEvent = null;
                ui.recBtn.textContent = "‚óè REC (0)"; ui.recBtn.classList.add('recording'); ui.exportBtn.style.display = 'none';
            } else {
                if(currentNoteEvent) recordedNotes.push({...currentNoteEvent, duration: Date.now()-noteStartTime});
                ui.recBtn.textContent = "‚óè REC"; ui.recBtn.classList.remove('recording');
                if(recordedNotes.length) ui.exportBtn.style.display = 'block';
            }
        };

        function processRecording(n, o) {
            const now = Date.now();
            if(currentNoteEvent && n===currentNoteEvent.note && o===currentNoteEvent.octave) return;
            if(currentNoteEvent) {
                recordedNotes.push({...currentNoteEvent, duration: now-noteStartTime});
                ui.recBtn.textContent = `‚óè REC (${recordedNotes.length})`;
            }
            if(n) { currentNoteEvent = {note:n, octave:o}; noteStartTime = now; } else currentNoteEvent = null;
        }

        // UPDATED: EXPORT with Standard MusicXML Header for 60 BPM / 1000 Div
        ui.exportBtn.onclick = () => {
            let x = `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE score-partwise PUBLIC "-//Recordare//DTD MusicXML 4.0 Partwise//EN" "http://www.musicxml.org/dtds/partwise.dtd">
<score-partwise version="4.0">
  <part-list><score-part id="P1"><part-name>Rec</part-name></score-part></part-list>
  <part id="P1">
    <measure number="1">
      <attributes>
        <divisions>1000</divisions>
        <time><beats>4</beats><beat-type>4</beat-type></time>
      </attributes>
      <direction placement="above"><direction-type><metronome><beat-unit>quarter</beat-unit><per-minute>60</per-minute></metronome></direction-type></direction>`;
            
            recordedNotes.forEach(n=>{
                let s=n.note[0], a=n.note.includes('#');
                x+=`<note><pitch><step>${s}</step>${a?'<alter>1</alter>':''}<octave>${n.octave}</octave></pitch><duration>${n.duration}</duration><type>whole</type></note>`;
            });
            x+=`</measure></part></score-partwise>`;
            const blob = new Blob([x], { type: 'text/xml' });
            const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `rec_${Date.now()}.musicxml`; a.click();
        };

        const playbackManager = {
            timeouts: [],
            isPlaying: false,
            stop: function() {
                this.timeouts.forEach(id => clearTimeout(id));
                this.timeouts = [];
                this.isPlaying = false;
                ui.importBtn.classList.remove('playing');
                ui.importBtn.textContent = "‚ñ∂ PLAY";
                document.querySelectorAll('.key.pressed').forEach(k => k.classList.remove('pressed'));
            }
        };

        const fileInput = document.getElementById('fileInput');
        ui.importBtn.onclick = () => {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            if (playbackManager.isPlaying) { playbackManager.stop(); } else { fileInput.click(); }
        };







// ==========================================
        // BEGIN FIX: v6.4 MusicXML/MXL Robust Import
        // ==========================================

        const fileInput = document.getElementById('fileInput');

        // Play Button Click Handler
        ui.importBtn.onclick = async () => {
            // [Fix 4] iOS Audio Unlock: Must happen on direct user interaction
            if (audioCtx.state === 'suspended') {
                await audioCtx.resume();
            }

            if (playbackManager.isPlaying) { 
                playbackManager.stop(); 
            } else { 
                // Reset value to ensure onchange triggers even for same file
                fileInput.value = ''; 
                fileInput.click(); 
            }
        };

        // File Selection Handler
        fileInput.onchange = async (e) => {
            const f = e.target.files[0];
            if (!f) return;

            // UI Feedback
            ui.importBtn.textContent = "‚è≥ LOADING...";

            try {
                let xmlContent = "";
                
                // [Fix 1] MXL Handling: Read META-INF/container.xml first
                if (f.name.toLowerCase().endsWith('.mxl')) {
                    if (!window.JSZip) throw new Error("JSZip not loaded");
                    
                    const zip = await JSZip.loadAsync(f);
                    
                    // Try to find the rootfile path from container.xml
                    const containerFile = zip.file("META-INF/container.xml");
                    let rootPath = "";
                    
                    if (containerFile) {
                        const containerText = await containerFile.async("string");
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(containerText, "text/xml");
                        const rootfile = doc.querySelector("rootfile");
                        if (rootfile) {
                            rootPath = rootfile.getAttribute("full-path");
                        }
                    }

                    // Fallback logic if container.xml fails or path is weird
                    let scoreFile = rootPath ? zip.file(rootPath) : null;
                    
                    if (!scoreFile) {
                        // Heuristic: Find first .xml that is NOT container.xml
                        const files = Object.keys(zip.files);
                        const candidate = files.find(name => 
                            name.toLowerCase().endsWith(".xml") && 
                            !name.includes("META-INF") && 
                            !name.startsWith(".")
                        );
                        if (candidate) scoreFile = zip.file(candidate);
                    }

                    if (scoreFile) {
                        xmlContent = await scoreFile.async("string");
                    } else {
                        throw new Error("No valid MusicXML file found in .mxl");
                    }
                } else {
                    // Standard Text Read for .xml / .musicxml
                    xmlContent = await new Promise((resolve, reject) => {
                        const r = new FileReader();
                        r.onload = e => resolve(e.target.result);
                        r.onerror = e => reject(e);
                        r.readAsText(f);
                    });
                }

                // Parse and Play
                playMusicXML(xmlContent);

            } catch(err) {
                alert("Import Failed: " + err.message);
                ui.importBtn.textContent = "‚ñ∂ PLAY";
            }
        };

        function playMusicXML(xmlString) {
            console.log("--- Starting Parsing ---");
            const parser = new DOMParser();
            const doc = parser.parseFromString(xmlString, "text/xml");

            // [Fix] Check for Parser Error
            const parseError = doc.querySelector("parsererror");
            if (parseError) {
                alert("XML Parsing Error: Invalid XML format.");
                ui.importBtn.textContent = "‚ñ∂ PLAY";
                return;
            }

            // 1. Extract Global Settings (Tempo & Divisions)
            // [Fix 2] Robust Division/Tempo Finding
            let divisions = 480; // Standard default
            const divTag = doc.querySelector("divisions");
            if (divTag) {
                const val = parseFloat(divTag.textContent);
                if (!isNaN(val) && val > 0) divisions = val;
            }

            let bpm = 120; // Standard default
            // Try standard <per-minute>
            const perMinTag = doc.querySelector("per-minute");
            if (perMinTag) {
                bpm = parseFloat(perMinTag.textContent);
            } else {
                // Try <sound tempo="...">
                const soundTag = doc.querySelector("sound[tempo]");
                if (soundTag) {
                    bpm = parseFloat(soundTag.getAttribute("tempo"));
                }
            }
            if (isNaN(bpm) || bpm <= 0) bpm = 120;

            console.log(`Detected: Divisions=${divisions}, BPM=${bpm}`);

            // Detect if this is our own recorder file (legacy support)
            // Our recorder uses divisions=1000 and treats duration as raw ms
            const isLegacyRecorder = (divisions === 1000 && !doc.querySelector("per-minute") && !doc.querySelector("sound"));

            // 2. Parse Notes
            const noteNodes = doc.querySelectorAll("note");
            if (noteNodes.length === 0) {
                alert("No notes found in this XML.");
                ui.importBtn.textContent = "‚ñ∂ PLAY";
                return;
            }

            // Update UI State
            playbackManager.isPlaying = true;
            ui.importBtn.classList.add('playing'); 
            ui.importBtn.textContent = "‚ñ† STOP";

            let absoluteTime = 0; // In seconds
            let maxDuration = 0;

            // Audio Context Time Reference
            // Add slight delay (0.1s) to allow UI to update and audio buffer to settle
            const startTimeRef = audioCtx.currentTime + 0.1;

            noteNodes.forEach(n => {
                // XML Tags
                const isRest = n.querySelector("rest") !== null;
                const isChord = n.querySelector("chord") !== null;
                const isGrace = n.querySelector("grace") !== null;
                
                const stepNode = n.querySelector("step");
                const octaveNode = n.querySelector("octave");
                const alterNode = n.querySelector("alter");
                const durationNode = n.querySelector("duration");

                // Skip grace notes for this simple player (simpler logic)
                if (isGrace) return;
                
                // Calculate Duration in Seconds
                let durationSec = 0;
                if (durationNode) {
                    const rawDur = parseFloat(durationNode.textContent);
                    if (!isNaN(rawDur)) {
                        if (isLegacyRecorder) {
                            durationSec = rawDur / 1000; // Raw MS to Seconds
                        } else {
                            // Standard Formula: (Duration / Divisions) * (60 / BPM)
                            durationSec = (rawDur / divisions) * (60 / bpm);
                        }
                    }
                }

                // Safety Clamp for very short notes
                if (durationSec < 0.05) durationSec = 0.05;

                // [Fix 3] Chord Logic:
                // If it is a chord, it shares the start time of the previous note.
                // It does NOT advance absoluteTime.
                // We assume XML is ordered: Note A, then Note B (chord) means B plays with A.
                
                // However, simpler loop logic:
                // If NOT chord, we advance absoluteTime AFTER scheduling.
                // If IS chord, we schedule at current absoluteTime (which hasn't advanced yet relative to the base note).
                // Wait, standard MusicXML `chord` tag appears on the *second* note.
                // Note 1 (Duration 1) -> advances time? No, we need to know if next is chord.
                // Better approach: Backtrack? No.
                // Approach:
                // If `chord`, use `absoluteTime - lastStepDuration`. 
                // BUT, cleaner approach: Only advance `absoluteTime` if the note is NOT part of a chord block? 
                // Actually, standard XML parser logic:
                // Note A (dur=4) -> absoluteTime stays 0.
                // Note B (chord, dur=4) -> absoluteTime stays 0.
                // Next Note C -> absoluteTime becomes 0 + 4.
                
                // Implementation for linear reading:
                // If it is a chord, reset start time to `lastNoteStartTime`.
                
                let noteStartTime = absoluteTime;

                if (isChord) {
                     // Move back to start of the cluster
                     // We need to track the start time of the "current chord stack"
                     // For simplicity in this linear reader, we assume `absoluteTime` was advanced by the previous note
                     // and we need to rewind. 
                     // Actually, easiest way:
                     // Don't advance `absoluteTime` inside the loop until we know the next note is NOT a chord?
                     // Or, just use a variable `clusterStartTime`.
                } 
                
                // Re-thinking simpler logic that works for 99% cases:
                // We use a variable `stepDuration`.
                // If !chord, we commit the previous stepDuration to absoluteTime.
                
                // Let's rely on the fact that `chord` tag means "play with previous".
                // We need to undo the time advance of the previous note? 
                // No, let's change how we advance time.
                
                // CORRECT LOGIC:
                if (isChord) {
                    // It starts at the same time as the previous note
                    // So we use 'lastNoteStart'
                    // We do NOT update absoluteTime here because the 'main' note already defined the duration of this block
                    noteStartTime = window.lastNoteStart || 0;
                } else {
                    // It's a new note/rest.
                    noteStartTime = absoluteTime;
                    window.lastNoteStart = absoluteTime; // Save for potential chords
                    
                    // Advance time for the NEXT note
                    absoluteTime += durationSec;
                }

                maxDuration = Math.max(maxDuration, noteStartTime + durationSec);

                // If it's a rest, we just advanced time (above), no sound to play.
                if (isRest) return;

                // Parse Pitch
                if (stepNode && octaveNode) {
                    let step = stepNode.textContent;
                    let alter = alterNode ? parseInt(alterNode.textContent) : 0;
                    let oct = parseInt(octaveNode.textContent);

                    // Handle Flats/Sharps to match our notes array
                    // Our array: C, C#, D, D#, E, F, F#, G, G#, A, A#, B
                    let noteName = step;
                    if (alter === 1) noteName += "#";
                    if (alter === -1) {
                        // Convert Flat to Sharp (e.g., Db -> C#)
                        const flatMap = { "D":"C#", "E":"D#", "G":"F#", "A":"G#", "B":"A#", "C":"B", "F":"E" }; // Cb->B, Fb->E edge cases
                        if (flatMap[step]) noteName = flatMap[step];
                        // Octave adjustment for Cb? Let's ignore complex edge cases for now
                    }

                    // Calculate Frequency
                    // A4 calibration
                    const baseFreq = appSettings.a4; 
                    const allNotes = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
                    const semitoneIndex = allNotes.indexOf(noteName);
                    
                    if (semitoneIndex !== -1) {
                        const noteNum = (oct + 1) * 12 + semitoneIndex;
                        const freq = baseFreq * Math.pow(2, (noteNum - 69) / 12);

                        // Schedule Audio
                        const tId1 = setTimeout(() => {
                            if(!playbackManager.isPlaying) return;
                            
                            const osc = audioCtx.createOscillator(); 
                            const g = audioCtx.createGain();
                            
                            osc.frequency.value = freq; 
                            
                            // Envelope to avoid clicking
                            const now = audioCtx.currentTime;
                            g.gain.setValueAtTime(0, now); 
                            g.gain.linearRampToValueAtTime(masterVolume * 0.3, now + 0.02); 
                            g.gain.linearRampToValueAtTime(0, now + durationSec - 0.02);
                            
                            osc.connect(g); 
                            g.connect(audioCtx.destination); 
                            
                            osc.start(now); 
                            osc.stop(now + durationSec);
                            
                            // Visual Feedback
                            const keyEl = document.querySelector(`.key[data-note="${noteName}"]`);
                            if(keyEl) keyEl.classList.add('pressed');

                        }, (startTimeRef + noteStartTime - audioCtx.currentTime) * 1000);

                        // Schedule Visual Cleanup
                        const tId2 = setTimeout(() => {
                            if(!playbackManager.isPlaying) return;
                            const keyEl = document.querySelector(`.key[data-note="${noteName}"]`);
                            if(keyEl) keyEl.classList.remove('pressed');
                        }, (startTimeRef + noteStartTime + durationSec - audioCtx.currentTime) * 1000);
                        
                        playbackManager.timeouts.push(tId1, tId2);
                    }
                }
            });

            // Schedule Finish
            const finishId = setTimeout(() => { 
                playbackManager.stop(); 
            }, (startTimeRef + maxDuration - audioCtx.currentTime) * 1000 + 500); // +500ms buffer
            playbackManager.timeouts.push(finishId);
        }

        // ==========================================
        // END FIX: v6.4 MusicXML/MXL Robust Import
        // ==========================================
    </script>
</body>
</html>
