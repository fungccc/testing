<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Tuner T1 - Turbo Piano (v5.0)</title>
    <style>
        :root {
            --bg-color: #121212;
            --text-main: #ffffff;
            --accent-green: #00e676; /* Brighter green for speed feel */
            --accent-red: #ff1744;
            --accent-blue: #2979ff;
            --panel-bg: #1e1e1e;
            --modal-bg: rgba(0, 0, 0, 0.95);
        }
        body {
            background-color: var(--bg-color);
            color: var(--text-main);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            margin: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
            user-select: none; /* Prevent selection lag */
        }
        
        header {
            display: flex;
            justify-content: space-between;
            padding: 15px;
            align-items: center;
            background: #000;
        }
        .settings-btn { cursor: pointer; font-size: 1.5rem; }
        
        .action-area { display: flex; gap: 8px; }
        .btn {
            border: 1px solid #555;
            background: transparent;
            color: #ccc;
            padding: 6px 14px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 5px;
            font-weight: 600;
        }
        .rec-btn.recording { background: var(--accent-red); color: white; border-color: var(--accent-red); }
        .play-btn { color: var(--accent-blue); border-color: var(--accent-blue); }
        .play-btn.playing { background: var(--accent-blue); color: white; }
        .hidden-input { display: none; }

        /* Main Display - Optimization: Use transform for potentially better rendering */
        .readout {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            align-items: center;
            text-align: center;
            padding: 15px 0;
            background: #181818;
        }
        .hz-val { font-size: 1.4rem; color: #888; font-family: monospace; }
        .hz-label { font-size: 0.6rem; color: #555; display: block; letter-spacing: 1px; }
        
        .note-container { display: flex; align-items: baseline; justify-content: center; width: 140px;}
        .note-display { font-size: 6rem; font-weight: 700; line-height: 1; color: #fff; text-shadow: 0 0 20px rgba(255,255,255,0.1); }
        .note-octave { font-size: 2.5rem; color: #aaa; margin-left: 5px;}
        
        .cents-val { font-size: 1.4rem; color: #888; font-family: monospace; }

        /* Performance Visualizer */
        .viz-container {
            flex: 1;
            position: relative;
            background: #000;
            overflow: hidden;
            border-top: 1px solid #333;
            border-bottom: 1px solid #333;
        }
        canvas { width: 100%; height: 100%; display: block; }
        .start-btn {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            padding: 15px 40px;
            background: var(--accent-green);
            border: none;
            color: #000;
            font-weight: bold;
            border-radius: 40px;
            cursor: pointer;
            font-size: 1.2rem;
            z-index: 10;
            box-shadow: 0 0 20px rgba(0, 230, 118, 0.4);
        }

        /* Keyboard */
        .keyboard { padding: 10px 5px; background: #080808; }
        .keys-row { display: flex; justify-content: center; gap: 6px; flex-wrap: wrap; }
        .key {
            width: 40px; height: 55px; background: #222; border-radius: 0 0 4px 4px;
            display: flex; align-items: flex-end; justify-content: center;
            font-weight: bold; color: #fff; font-size: 1rem; padding-bottom: 5px;
            transition: transform 0.05s, background 0.05s; /* Faster transition */
        }
        .key.sharp { 
            background: #333; height: 35px; margin-bottom: 20px; 
            border-radius: 0 0 4px 4px; z-index: 2; align-items: center; padding-bottom: 0;
        }
        .key.active { background: var(--accent-green) !important; color: #000 !important; transform: translateY(2px); box-shadow: 0 0 15px var(--accent-green); }
        .key.playback-active { background: var(--accent-blue) !important; color: #fff !important; transform: translateY(2px); }

        footer { text-align: center; font-size: 0.7rem; color: #444; padding: 8px; background: #000; }

        /* Modal */
        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: var(--modal-bg); z-index: 100; }
        .modal-content { max-width: 500px; margin: 60px auto; padding: 25px; background: #1a1a1a; border-radius: 12px; border: 1px solid #333; }
        .close-btn { float: right; font-size: 1.5rem; cursor: pointer; color: #888; }
        
        .mode-options { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 20px; }
        .mode-card { background: #222; border: 2px solid #333; padding: 15px; cursor: pointer; border-radius: 8px; transition: 0.2s; }
        .mode-card:hover { border-color: #555; }
        .mode-card.selected { border-color: var(--accent-green); background: rgba(0, 230, 118, 0.1); }
        .mode-title { display: block; font-weight: bold; color: #fff; margin-bottom: 5px; }
        .mode-desc { font-size: 0.8rem; color: #888; line-height: 1.4; }
        
        .perf-badge { 
            display: inline-block; padding: 2px 6px; border-radius: 4px; 
            font-size: 0.7rem; font-weight: bold; margin-bottom: 10px;
        }
        .badge-fast { background: var(--accent-green); color: black; }
        .badge-slow { background: #ff9800; color: black; }

    </style>
</head>
<body>

    <header>
        <div class="settings-btn" id="openSettings">‚öôÔ∏è</div>
        <div style="font-weight:900; letter-spacing:1px; color:#fff;">TUNER <span style="color:var(--accent-green)">T1</span></div>
        <div class="action-area">
            <button class="btn rec-btn" id="recordBtn">‚óè REC</button>
            <button class="btn rec-btn" id="exportBtn" style="display:none; border-color:#fff; color:#fff;">‚¨á XML</button>
            <input type="file" id="fileInput" class="hidden-input" accept="*">
            <button class="btn play-btn" id="importBtn">‚ñ∂ PLAY XML</button>
        </div>
    </header>

    <div class="readout">
        <div>
            <span id="hz" class="hz-val">0.0</span>
            <span class="hz-label">HERTZ</span>
        </div>
        <div class="note-container">
            <span id="note" class="note-display">-</span>
            <span id="octave" class="note-octave"></span>
        </div>
        <div>
            <span id="cents" class="cents-val">0.0</span>
            <span class="hz-label">CENTS</span>
        </div>
    </div>

    <div class="viz-container">
        <button class="start-btn" id="startBtn">‚ö° ÂïüÂãïÊ•µÈÄüÊ®°Âºè</button>
        <canvas id="tunerCanvas"></canvas>
    </div>

    <div class="keyboard">
        <div class="keys-row" style="margin-bottom: -20px; padding-left: 20px;">
            <div class="key sharp" data-note="C#">C#</div>
            <div class="key sharp" data-note="D#">D#</div>
            <div style="width: 46px; pointer-events: none;"></div> <div class="key sharp" data-note="F#">F#</div>
            <div class="key sharp" data-note="G#">G#</div>
            <div class="key sharp" data-note="A#">A#</div>
        </div>
        <div class="keys-row">
            <div class="key" data-note="C">C</div>
            <div class="key" data-note="D">D</div>
            <div class="key" data-note="E">E</div>
            <div class="key" data-note="F">F</div>
            <div class="key" data-note="G">G</div>
            <div class="key" data-note="A">A</div>
            <div class="key" data-note="B">B</div>
        </div>
    </div>
    
    <footer>Ë±êÁãÇÂá∫ÂìÅ ‚Ä¢ Turbo Engine v5.0</footer>

    <div id="settingsModal" class="modal">
        <div class="modal-content">
            <span class="close-btn" id="closeSettings">&times;</span>
            <h2 style="color:white; margin-top:0;">DSP ÂºïÊìéË®≠ÂÆö</h2>
            
            <div class="mode-options">
                <div class="mode-card selected" onclick="setMode('turbo')" id="modeTurbo">
                    <span class="perf-badge badge-fast">Âª∂ÈÅ≤ 46ms</span>
                    <span class="mode-title">üéπ ÈãºÁê¥Ê•µÈÄü (Piano Turbo)</span>
                    <span class="mode-desc">
                        ÈáùÂ∞çÈãºÁê¥‰∏≠È´òÈü≥„ÄÅÂêâ‰ªñÂÑ™Âåñ„ÄÇ<br>
                        ‚Ä¢ ÁäßÁâ≤Ê•µ‰ΩéÈ†ª (A0-E1) Ê∫ñÂ∫¶<br>
                        ‚Ä¢ ÊèõÂèñ UI Áû¨ÊôÇÂèçÊáâ
                    </span>
                </div>
                <div class="mode-card" onclick="setMode('bass')" id="modeBass">
                    <span class="perf-badge badge-slow">Âª∂ÈÅ≤ 92ms</span>
                    <span class="mode-title">üê¢ Ê∑±Â±§‰ΩéÈü≥ (Deep Bass)</span>
                    <span class="mode-desc">
                        ÈáùÂ∞ç 5Âº¶Ë≤ùÊñØ„ÄÅÂ§ßÊèêÁê¥ÂÑ™Âåñ„ÄÇ<br>
                        ‚Ä¢ ÂÆåÊï¥ÊîØÊè¥ 20Hz~<br>
                        ‚Ä¢ ÂèçÊáâËºÉÊÖ¢ÔºåÈÅ©ÂêàË™øÈï∑Èü≥
                    </span>
                </div>
            </div>
        </div>
    </div>

    <script>
        // === CORE VARIABLES ===
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)({ latencyHint: 'interactive' });
        let analyser, dataArray;
        let isRunning = false;
        
        // Settings
        let currentFFTSize = 2048; // Default to Turbo
        let downsampleStep = 4; // Skip samples to calculate faster (v5.0 Feature)
        
        const A4 = 440;
        const notes = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
        
        // DOM Caching (Performance)
        const ui = {
            hz: document.getElementById('hz'),
            note: document.getElementById('note'),
            oct: document.getElementById('octave'),
            cents: document.getElementById('cents'),
            keys: document.querySelectorAll('.key'),
            recBtn: document.getElementById('recordBtn'),
            exportBtn: document.getElementById('exportBtn'),
            importBtn: document.getElementById('importBtn'),
            startBtn: document.getElementById('startBtn')
        };
        const canvas = document.getElementById('tunerCanvas');
        const ctx = canvas.getContext('2d', { alpha: false }); // Optimize Canvas

        // History
        const historySize = 300; 
        const pitchHistory = new Array(historySize).fill(null);
        let lastNoteName = ""; // For deduping UI updates

        // === RECORDER VARS ===
        let isRecording = false;
        let recordedNotes = []; 
        let currentNoteEvent = null; 
        let noteStartTime = 0;
        const MIN_NOTE_DURATION = 80; // Reduced for faster piano runs

        // === INITIALIZATION ===
        ui.startBtn.onclick = async function() {
            this.style.display = 'none';
            if (audioCtx.state === 'suspended') await audioCtx.resume();
            
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: { 
                        echoCancellation: false, 
                        autoGainControl: false, 
                        noiseSuppression: false, // Critical for raw instrument data
                        latency: 0
                    } 
                });
                analyser = audioCtx.createAnalyser();
                setMode('turbo'); // Default to Turbo
                const source = audioCtx.createMediaStreamSource(stream);
                source.connect(analyser);
                isRunning = true;
                update();
            } catch (e) { alert("ÁÑ°Ê≥ïÂ≠òÂèñÈ∫•ÂÖãÈ¢®"); }
        };

        // Modal Logic
        const modal = document.getElementById('settingsModal');
        document.getElementById('openSettings').onclick = () => modal.style.display = 'block';
        document.getElementById('closeSettings').onclick = () => modal.style.display = 'none';
        
        window.setMode = (mode) => {
            if (mode === 'turbo') {
                currentFFTSize = 2048;
                downsampleStep = 4; // High speed
                document.getElementById('modeTurbo').className = 'mode-card selected';
                document.getElementById('modeBass').className = 'mode-card';
            } else {
                currentFFTSize = 4096;
                downsampleStep = 2; // More precision
                document.getElementById('modeTurbo').className = 'mode-card';
                document.getElementById('modeBass').className = 'mode-card selected';
            }
            if (analyser) {
                analyser.fftSize = currentFFTSize;
                dataArray = new Float32Array(analyser.fftSize);
            }
        };

        // === TURBO YIN ALGORITHM (v5.0 Optimized) ===
        // Optimized for speed over extreme precision
        function detectPitchTurbo(buffer, sampleRate) {
            const threshold = 0.15; // Slightly looser threshold for faster locking
            const bufferSize = buffer.length;
            const halfSize = Math.floor(bufferSize / 2);
            
            // Optimization 1: We don't alloc new array every frame if possible, 
            // but for simplicity here we keep it. 
            // The BIG optimization is the loop step.
            const yinBuffer = new Float32Array(halfSize);

            // Step 1: Difference (The bottleneck)
            // v5.0: i += downsampleStep (skips calculations)
            for (let t = 0; t < halfSize; t += 1) { // tau step must be 1 for resolution
                let sum = 0;
                // Inner loop optimization: heavy downsampling
                for (let i = 0; i < halfSize; i += downsampleStep) { 
                    const d = buffer[i] - buffer[i + t];
                    sum += d * d;
                }
                yinBuffer[t] = sum;
            }

            // Step 2: CMND
            yinBuffer[0] = 1;
            let runningSum = 0;
            for (let t = 1; t < halfSize; t++) {
                runningSum += yinBuffer[t];
                yinBuffer[t] *= t / runningSum;
            }

            // Step 3: Absolute Threshold
            let tau = -1;
            for (let t = 2; t < halfSize; t++) {
                if (yinBuffer[t] < threshold) {
                    while (t + 1 < halfSize && yinBuffer[t + 1] < yinBuffer[t]) t++;
                    tau = t;
                    break;
                }
            }
            
            if (tau === -1) return -1;

            // Step 4: Parabolic Interpolation (Crucial for Cents)
            const x0 = yinBuffer[tau - 1];
            const x2 = yinBuffer[tau + 1];
            const x1 = yinBuffer[tau];
            const betterTau = tau + (x2 - x0) / (2 * (2 * x1 - x2 - x0));

            return sampleRate / betterTau;
        }

        // === MAIN LOOP ===
        function update() {
            if (!isRunning) return;
            
            analyser.getFloatTimeDomainData(dataArray);
            
            // Fast RMS check
            let sum = 0;
            // Only check every 8th sample for RMS to save CPU
            for (let i = 0; i < dataArray.length; i+=8) sum += dataArray[i] * dataArray[i];
            const rms = Math.sqrt(sum / (dataArray.length/8));

            let cents = null;
            let detectedNote = null;
            let detectedOctave = null;

            // Noise Gate
            if (rms > 0.015) { // Slightly higher gate to prevent ghost notes
                const pitch = detectPitchTurbo(dataArray, audioCtx.sampleRate);
                
                // Allow lower freqs in Bass Mode, Higher in Turbo
                const minFreq = currentFFTSize === 4096 ? 25 : 55; // Turbo ignores < A1

                if (pitch !== -1 && pitch > minFreq && pitch < 4200) {
                    const noteNum = 12 * (Math.log(pitch / A4) / Math.log(2));
                    const roundedNote = Math.round(noteNum) + 69;
                    detectedNote = notes[roundedNote % 12];
                    detectedOctave = Math.floor(roundedNote / 12) - 1;
                    
                    const freqFromNote = A4 * Math.pow(2, (roundedNote - 69) / 12);
                    cents = Math.floor(1200 * Math.log(pitch / freqFromNote) / Math.log(2));

                    // UI Updates - Only touch DOM if needed or for volatile values
                    ui.hz.textContent = pitch.toFixed(1); // fast update
                    ui.cents.textContent = (cents > 0 ? "+" : "") + cents;
                    ui.cents.style.color = Math.abs(cents) < 10 ? "var(--accent-green)" : "#888";

                    if (lastNoteName !== detectedNote + detectedOctave) {
                        ui.note.textContent = detectedNote;
                        ui.oct.textContent = detectedOctave;
                        lastNoteName = detectedNote + detectedOctave;
                        
                        // Active Key Highlight
                        ui.keys.forEach(k => k.classList.remove('active'));
                        const k = document.querySelector(`.key[data-note="${detectedNote}"]`);
                        if(k) k.classList.add('active');
                    }
                }
            }

            if (isRecording) processRecording(detectedNote, detectedOctave);

            // Visualizer logic (same as before)
            pitchHistory.pop();
            pitchHistory.unshift(cents);
            drawVisualizer();
            
            requestAnimationFrame(update);
        }

        // === RECORDER & PLAYBACK (Ported from v4.0) ===
        ui.recBtn.onclick = () => {
            isRecording = !isRecording;
            if (isRecording) {
                recordedNotes = [];
                currentNoteEvent = null;
                ui.recBtn.textContent = "‚ñ† STOP";
                ui.recBtn.classList.add('recording');
                ui.exportBtn.style.display = 'none';
            } else {
                finishCurrentNote();
                ui.recBtn.textContent = "‚óè REC";
                ui.recBtn.classList.remove('recording');
                if (recordedNotes.length > 0) ui.exportBtn.style.display = 'block';
            }
        };

        ui.exportBtn.onclick = () => {
            const xml = generateMusicXML(recordedNotes);
            // iOS ‰øÆÊ≠£ÔºöÂ∞á MIME type ÊîπÁÇ∫Á¥îÊñáÂ≠óÔºåÁ¢∫‰øùÊâãÊ©ü‰∏çÊúÉÂ∞áÂÖ∂Ë¶ñÁÇ∫‰∏çÊòé‰∫åÈÄ≤Âà∂Ê™î
const blob = new Blob([xml], { type: 'text/xml' });

            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `piano_rec_${Date.now()}.musicxml`;
            a.click();
        };

        // File Import
        const fileInput = document.getElementById('fileInput');
        ui.importBtn.onclick = () => fileInput.click();
        fileInput.onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => playMusicXML(e.target.result);
            reader.readAsText(file);
            fileInput.value = '';
        };

        // ... (Playback logic preserved from v4.0 but omitted here for brevity if unchanged, 
        // essentially reuse the same playTone and playMusicXML functions) ...
        
        // Re-injecting Playback Logic for completeness
        function playMusicXML(xmlString) {
             if (audioCtx.state === 'suspended') audioCtx.resume();
             const parser = new DOMParser();
             const xmlDoc = parser.parseFromString(xmlString, "text/xml");
             const noteNodes = xmlDoc.querySelectorAll("note");
             ui.importBtn.classList.add('playing');
             ui.importBtn.textContent = "PLAYING...";
             let currentTime = audioCtx.currentTime + 0.1;

             noteNodes.forEach((node) => {
                const step = node.querySelector("step")?.textContent;
                const octave = node.querySelector("octave")?.textContent;
                const alter = node.querySelector("alter")?.textContent;
                const dur = node.querySelector("duration")?.textContent;
                if (dur && step) {
                    const dSec = parseFloat(dur) / 1000;
                    let n = step + (alter==="1"?"#":"");
                    const freq = getFreq(n, parseInt(octave));
                    
                    playTone(freq, currentTime, dSec);
                    const delay = (currentTime - audioCtx.currentTime) * 1000;
                    
                    setTimeout(() => highlightKey(n, true), delay);
                    setTimeout(() => highlightKey(n, false), delay + (dSec*1000));
                    currentTime += dSec;
                }
             });
             setTimeout(() => {
                 ui.importBtn.classList.remove('playing');
                 ui.importBtn.textContent = "‚ñ∂ PLAY XML";
             }, (currentTime - audioCtx.currentTime)*1000);
        }

        function playTone(freq, t, d) {
            const osc = audioCtx.createOscillator();
            const g = audioCtx.createGain();
            osc.frequency.value = freq;
            g.gain.setValueAtTime(0, t);
            g.gain.linearRampToValueAtTime(0.3, t + 0.02);
            g.gain.linearRampToValueAtTime(0, t + d);
            osc.connect(g); g.connect(audioCtx.destination);
            osc.start(t); osc.stop(t+d);
        }
        
        function highlightKey(n, active) {
            const k = document.querySelector(`.key[data-note="${n}"]`);
            if(k) {
                if(active) k.classList.add('playback-active');
                else k.classList.remove('playback-active');
            }
        }
        
        function getFreq(note, octave) {
            const semitones = notes.indexOf(note);
            const midi = (octave + 1) * 12 + semitones;
            return 440 * Math.pow(2, (midi - 69) / 12);
        }

        function processRecording(note, octave) {
            const now = Date.now();
            if (currentNoteEvent && note === currentNoteEvent.note && octave === currentNoteEvent.octave) return;
            if (currentNoteEvent) {
                const d = now - noteStartTime;
                if (d > MIN_NOTE_DURATION) recordedNotes.push({ ...currentNoteEvent, duration: d });
            }
            if (note) { currentNoteEvent = { note, octave }; noteStartTime = now; } 
            else { currentNoteEvent = null; }
        }
        
        function finishCurrentNote() {
            if (currentNoteEvent && isRecording) {
                 const d = Date.now() - noteStartTime;
                 if (d > MIN_NOTE_DURATION) recordedNotes.push({ ...currentNoteEvent, duration: d });
            }
        }
        
        function generateMusicXML(data) { // Minimal XML
            let x = `<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE score-partwise PUBLIC "-//Recordare//DTD MusicXML 4.0 Partwise//EN" "http://www.musicxml.org/dtds/partwise.dtd"><score-partwise version="4.0"><part-list><score-part id="P1"><part-name>Rec</part-name></score-part></part-list><part id="P1"><measure number="1"><attributes><divisions>1000</divisions></attributes>`;
            data.forEach(n=>{
                let s=n.note[0], a=n.note.includes('#');
                x+=`<note><pitch><step>${s}</step>${a?'<alter>1</alter>':''}<octave>${n.octave}</octave></pitch><duration>${n.duration}</duration><type>whole</type></note>`;
            });
            return x+`</measure></part></score-partwise>`;
        }

        function drawVisualizer() {
            const w = canvas.parentElement.clientWidth;
            const h = canvas.parentElement.clientHeight;
            canvas.width = w; canvas.height = h;
            
            const cw = w * 0.15;
            ctx.fillStyle = "#ff5252"; ctx.fillRect(0,0,w/2-cw/2,h);
            ctx.fillStyle = "#00e676"; ctx.fillRect(w/2-cw/2,0,cw,h);
            ctx.fillStyle = "#222"; ctx.fillRect(w/2+cw/2,0,w,h);
            
            ctx.strokeStyle = "#fff"; ctx.lineWidth = 2; ctx.beginPath();
            const rh = h / historySize;
            for(let i=0; i<historySize; i+=2) { // Draw every 2nd line for performance
                if(pitchHistory[i]!==null) {
                    const v = Math.max(-50, Math.min(50, pitchHistory[i]));
                    const x = (v+50)/100 * w;
                    const y = i * rh;
                    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
                }
            }
            ctx.stroke();
        }
    </script>
</body>
</html>
