<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>CYBER DEFENSE // AR GAME</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --cyan: #00ffff;
            --pink: #ff0055;
            --orange: #ffaa00;
            --red: #ff3333;
            --bg-dark: rgba(0, 5, 10, 0.8);
        }
        body { margin: 0; padding: 0; overflow: hidden; background-color: #000; font-family: 'Orbitron', sans-serif; user-select: none; -webkit-user-select: none; }
        
        /* AR Background */
        #video-input { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            object-fit: cover; transform: scaleX(-1); z-index: 0;
            filter: contrast(1.1) brightness(0.8) hue-rotate(180deg); opacity: 0.8;
        }
        
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; }
        
        /* --- HUD UI --- */
        .hud-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none; }
        
        .top-bar { 
            position: absolute; top: 10px; width: 100%; display: flex; justify-content: space-between; padding: 0 20px; box-sizing: border-box; 
        }
        .level-info { text-align: left; border-left: 4px solid var(--cyan); padding-left: 10px; background: var(--bg-dark); }
        .timer-info { text-align: right; border-right: 4px solid var(--pink); padding-right: 10px; background: var(--bg-dark); }
        
        .big-text { font-size: 24px; font-weight: 900; color: #fff; text-shadow: 0 0 10px var(--cyan); }
        .sub-text { font-size: 12px; color: var(--cyan); letter-spacing: 2px; }
        .warning-text { color: var(--red); animation: blink 0.5s infinite; }

        /* 彈藥顯示 */
        #ammo-container {
            position: absolute; bottom: 20px; left: 20px; 
            background: var(--bg-dark); border: 2px solid var(--orange);
            padding: 10px; border-radius: 10px 0 10px 0;
            transform: skewX(-10deg);
        }
        .ammo-count { font-size: 32px; color: var(--orange); font-family: 'Share Tech Mono'; }
        .ammo-label { font-size: 10px; color: #aaa; }
        #reload-msg { display: none; color: var(--red); font-size: 14px; animation: blink 0.2s infinite; font-weight: bold;}

        /* 準心 */
        .crosshair {
            position: absolute; width: 40px; height: 40px; border: 2px dashed rgba(255, 255, 255, 0.5);
            border-radius: 50%; transform: translate(-50%, -50%); display: none;
            transition: width 0.1s, height 0.1s;
        }
        #ch-left { border-color: var(--orange); } /* 機槍 */
        #ch-right { border-color: var(--cyan); } /* 衝擊波 */

        /* 暫停遮罩 */
        #pause-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); backdrop-filter: blur(5px);
            display: none; justify-content: center; align-items: center; z-index: 100;
        }
        .pause-text { font-size: 40px; color: var(--cyan); border: 2px solid var(--cyan); padding: 20px 40px; }

        /* 遊戲開始按鈕 */
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 200; display: flex; flex-direction: column;
            justify-content: center; align-items: center;
        }
        .start-btn {
            margin-top: 30px; padding: 20px 50px; font-size: 24px; color: var(--cyan);
            background: transparent; border: 2px solid var(--cyan); cursor: pointer;
            font-family: 'Orbitron'; font-weight: bold; box-shadow: 0 0 20px var(--cyan);
            pointer-events: auto;
        }

        /* 遊戲結束/過關 */
        #game-msg {
            position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%);
            font-size: 30px; text-align: center; color: #fff; text-shadow: 0 0 20px var(--pink);
            display: none; pointer-events: none; width: 100%;
        }

        @keyframes blink { 0% { opacity: 1; } 50% { opacity: 0.2; } 100% { opacity: 1; } }
    </style>
</head>
<body>

    <div id="start-screen">
        <h1 style="color:var(--cyan); text-shadow: 0 0 20px var(--cyan);">CYBER DEFENSE</h1>
        <div style="color:#aaa; text-align:center; line-height: 1.6; font-size: 14px;">
            L-HAND (1 Finger): SHOOT (12 Rounds)<br>
            L-HAND (Fist): RELOAD<br>
            L-HAND (Open): BLACK HOLE<br>
            R-HAND (Open): SHOCKWAVE<br>
            L-HAND (2/3): PAUSE / RESUME
        </div>
        <button class="start-btn" id="init-btn">INITIATE LINK</button>
    </div>

    <div id="pause-overlay">
        <div class="pause-text">SYSTEM PAUSED</div>
    </div>

    <video id="video-input" playsinline webkit-playsinline muted></video>
    
    <div class="hud-layer">
        <div class="top-bar">
            <div class="level-info">
                <div class="sub-text">CURRENT LEVEL</div>
                <div class="big-text" id="level-disp">1 / 8</div>
            </div>
            <div class="timer-info">
                <div class="sub-text">TIME REMAINING</div>
                <div class="big-text" id="time-disp">03:00</div>
            </div>
        </div>
        
        <div id="game-msg">WAVE CLEARED</div>

        <div id="ammo-container">
            <div class="ammo-label">AMMUNITION</div>
            <div class="ammo-count"><span id="ammo-val">12</span>/12</div>
            <div id="reload-msg">⚠ RELOAD REQUIRED (FIST)</div>
        </div>
        
        <div id="ch-left" class="crosshair"></div>
        <div id="ch-right" class="crosshair"></div>
    </div>

    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.128.0/build/three.module.js';
        import { HandLandmarker, FilesetResolver } from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/vision_bundle.js';

        // --- 遊戲參數 ---
        const GAME = {
            maxLevels: 8,
            levelDuration: 180, // 3分鐘 (秒)
            bossSpawnTime: 30,  // 最後30秒
            ammoMax: 12,
            bulletSpeed: 50,
            enemySpeedBase: 2,
            spawnRateBase: 100, // Frames
        };

        // --- 全域變數 ---
        let scene, camera, renderer;
        let handLandmarker, video;
        let lastTime = 0;
        
        // 遊戲狀態機
        const gameState = {
            active: false,
            paused: false,
            level: 1,
            timer: GAME.levelDuration,
            ammo: GAME.ammoMax,
            score: 0,
            isBossActive: false,
            lastShotTime: 0,
            lastReloadTime: 0,
            pauseToggleTime: 0
        };

        // 實體管理
        const entities = {
            bullets: [],
            enemies: [],
            particles: [] // 爆炸特效
        };

        // 手部狀態
        const hands = {
            left: { x: 0, y: 0, active: false, fingers: 0, gesture: '' },
            right: { x: 0, y: 0, active: false, fingers: 0, gesture: '' }
        };

        // 初始化
        document.getElementById('init-btn').addEventListener('click', async () => {
            document.getElementById('start-screen').style.display = 'none';
            await initSystem();
            startGame();
        });

        async function initSystem() {
            // Three.js Setup
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 50; 
            
            renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            // Lighting
            const light = new THREE.DirectionalLight(0xffffff, 1);
            light.position.set(0, 10, 10);
            scene.add(light);
            scene.add(new THREE.AmbientLight(0x404040));

            // MediaPipe Setup
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
                runningMode: "VIDEO", numHands: 2, minHandDetectionConfidence: 0.5
            });

            // Camera Setup
            video = document.getElementById('video-input');
            const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "user" }, audio: false });
            video.srcObject = stream;
            await new Promise(r => video.onloadedmetadata = () => { video.play(); r(); });
            
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function startGame() {
            gameState.active = true;
            gameState.level = 1;
            startLevel(1);
            animate();
        }

        function startLevel(lvl) {
            gameState.level = lvl;
            gameState.timer = GAME.levelDuration;
            gameState.isBossActive = false;
            
            // UI Update
            document.getElementById('level-disp').innerText = `${lvl} / ${GAME.maxLevels}`;
            document.getElementById('level-disp').classList.remove('warning-text');
            showMessage(`LEVEL ${lvl} START`);
            
            // 清除上一關的敵人
            entities.enemies.forEach(e => scene.remove(e.mesh));
            entities.enemies = [];
        }

        function showMessage(text, duration=2000) {
            const msgEl = document.getElementById('game-msg');
            msgEl.innerText = text;
            msgEl.style.display = 'block';
            setTimeout(() => { msgEl.style.display = 'none'; }, duration);
        }

        // --- 核心邏輯 Loop ---
        function animate() {
            requestAnimationFrame(animate);
            const now = performance.now();
            const delta = (now - lastTime) / 1000;
            lastTime = now;

            if (!gameState.active) return;

            detectHands();

            // 暫停邏輯
            if (gameState.paused) return;

            updateGameLogic(delta, now);
            updateEntities(delta);
            renderer.render(scene, camera);
        }

        // --- 手勢偵測與映射 ---
        function detectHands() {
            if (!handLandmarker || !video) return;
            const results = handLandmarker.detectForVideo(video, performance.now());
            
            hands.left.active = false;
            hands.right.active = false;

            if (results.landmarks) {
                results.landmarks.forEach((lm, index) => {
                    // 判斷左右手 (鏡像)
                    const handedness = results.handedness[index][0].categoryName; 
                    // MediaPipe "Left" = 畫面右邊 = 玩家右手 (因為是自拍鏡頭鏡像)
                    // MediaPipe "Right" = 畫面左邊 = 玩家左手
                    
                    const isPlayerLeft = handedness === "Right"; 
                    const handObj = isPlayerLeft ? hands.left : hands.right;
                    
                    handObj.active = true;
                    // 轉換座標到 Three.js 世界座標
                    // 視窗中心 (0,0), Z=0 (螢幕平面)
                    // X 範圍約 -40 ~ 40, Y 範圍約 -25 ~ 25 (取決於 FOV 和 Z距離)
                    const screenX = (lm[9].x - 0.5) * -2; // -1 to 1
                    const screenY = -(lm[9].y - 0.5) * 2; // -1 to 1
                    
                    // 投影到 Z=0 平面
                    const vec = new THREE.Vector3(screenX, screenY, 0.5);
                    vec.unproject(camera);
                    const dir = vec.sub(camera.position).normalize();
                    const distance = -camera.position.z / dir.z;
                    const pos = camera.position.clone().add(dir.multiplyScalar(distance));
                    
                    handObj.x = pos.x;
                    handObj.y = pos.y;
                    
                    // 手指計數
                    handObj.fingers = countFingers(lm);
                });
            }
            
            updateCrosshairs();
            handleInput();
        }

        function countFingers(lm) {
            let count = 0;
            if (lm[8].y < lm[6].y) count++; // Index
            if (lm[12].y < lm[10].y) count++; // Middle
            if (lm[16].y < lm[14].y) count++; // Ring
            if (lm[20].y < lm[18].y) count++; // Pinky
            // Thumb (simple x check)
            if (Math.abs(lm[4].x - lm[3].x) > 0.05) count++;
            return count;
        }

        function updateCrosshairs() {
            const chl = document.getElementById('ch-left');
            const chr = document.getElementById('ch-right');
            
            if (hands.left.active) {
                chl.style.display = 'block';
                // 轉回 CSS 像素座標
                const cx = (hands.left.x / (window.innerWidth/20)) * 50 + 50; // 近似映射
                // 這裡偷懶直接用 MediaPipe 原始座標比較準
                // 重新計算 UI 座標
                // 我們在 detectHands 裡只存了 world pos，這裡需要 UI pos... 
                // 簡單起見，直接讓 cursor 跟隨 world pos 投影
                const screenPos = new THREE.Vector3(hands.left.x, hands.left.y, 0).project(camera);
                chl.style.left = `${(screenPos.x + 1) * 50}%`;
                chl.style.top = `${(-screenPos.y + 1) * 50}%`;
            } else {
                chl.style.display = 'none';
            }

            if (hands.right.active) {
                chr.style.display = 'block';
                const screenPos = new THREE.Vector3(hands.right.x, hands.right.y, 0).project(camera);
                chr.style.left = `${(screenPos.x + 1) * 50}%`;
                chr.style.top = `${(-screenPos.y + 1) * 50}%`;
            } else {
                chr.style.display = 'none';
            }
        }

        // --- 輸入處理 (手勢觸發) ---
        function handleInput() {
            const now = performance.now();

            // 1. 暫停/繼續 (Left 2/3) - 防抖動
            if (now - gameState.pauseToggleTime > 1000) {
                if (hands.left.active && hands.left.fingers === 2 && !gameState.paused) {
                    gameState.paused = true;
                    document.getElementById('pause-overlay').style.display = 'flex';
                    gameState.pauseToggleTime = now;
                } else if (hands.left.active && hands.left.fingers === 3 && gameState.paused) {
                    gameState.paused = false;
                    document.getElementById('pause-overlay').style.display = 'none';
                    gameState.pauseToggleTime = now;
                }
            }
            if (gameState.paused) return;

            // 2. 左手操作
            if (hands.left.active) {
                // 射擊 (1指)
                if (hands.left.fingers === 1) {
                    if (gameState.ammo > 0 && now - gameState.lastShotTime > 100) { // 射速限制
                        shootBullet(hands.left.x, hands.left.y);
                        gameState.lastShotTime = now;
                    } else if (gameState.ammo <= 0) {
                        document.getElementById('reload-msg').style.display = 'block';
                    }
                }
                
                // 填彈 (握拳 0指)
                if (hands.left.fingers === 0) {
                    if (now - gameState.lastReloadTime > 1000 && gameState.ammo < GAME.ammoMax) {
                        gameState.ammo = GAME.ammoMax;
                        updateAmmoUI();
                        createEffect(hands.left.x, hands.left.y, 'reload');
                        gameState.lastReloadTime = now;
                    }
                }

                // 黑洞 (全開 5指)
                if (hands.left.fingers === 5) {
                    // 持續吸引
                    applyBlackHole(hands.left.x, hands.left.y);
                }
            }

            // 3. 右手操作 (重砲 - 全開 5指)
            if (hands.right.active && hands.right.fingers === 5) {
                applyShockwave(hands.right.x, hands.right.y);
            }
        }

        // --- 遊戲邏輯更新 ---
        function updateGameLogic(delta, now) {
            // 計時器
            gameState.timer -= delta;
            
            // Boss 生成檢查
            if (gameState.timer <= GAME.bossSpawnTime && !gameState.isBossActive) {
                spawnBoss();
                gameState.isBossActive = true;
                document.getElementById('level-disp').classList.add('warning-text');
                showMessage("WARNING: BOSS APPROACHING");
            }

            // 更新 UI 時間
            const mins = Math.floor(gameState.timer / 60);
            const secs = Math.floor(gameState.timer % 60);
            document.getElementById('time-disp').innerText = 
                `${mins.toString().padStart(2,'0')}:${secs.toString().padStart(2,'0')}`;

            // 過關判定
            if (gameState.timer <= 0) {
                if (gameState.level < GAME.maxLevels) {
                    startLevel(gameState.level + 1);
                } else {
                    showMessage("MISSION ACCOMPLISHED - YOU WIN!", 5000);
                    gameState.active = false;
                }
            }

            // 敵人生成 (隨著關卡變快)
            const spawnRate = Math.max(20, GAME.spawnRateBase - (gameState.level * 5));
            if (Math.floor(now) % spawnRate === 0 && !gameState.isBossActive) {
                spawnEnemy(false);
            }
        }

        // --- 武器系統 ---
        function shootBullet(x, y) {
            gameState.ammo--;
            updateAmmoUI();
            
            // 創建子彈 Mesh
            const geometry = new THREE.CylinderGeometry(0.2, 0.2, 2, 8);
            geometry.rotateX(Math.PI / 2);
            const material = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
            const bullet = new THREE.Mesh(geometry, material);
            
            bullet.position.set(x, y, 0); // 從手的位置發射
            scene.add(bullet);
            
            entities.bullets.push({
                mesh: bullet,
                velocity: new THREE.Vector3(0, 0, -GAME.bulletSpeed) // 向螢幕深處射擊
            });
        }

        function updateAmmoUI() {
            document.getElementById('ammo-val').innerText = gameState.ammo;
            if (gameState.ammo > 0) document.getElementById('reload-msg').style.display = 'none';
        }

        function applyBlackHole(x, y) {
            // 特效：畫一個黑圈
            // 邏輯：吸入敵人
            entities.enemies.forEach(enemy => {
                if (enemy.isBoss) return; // Boss 免疫黑洞
                
                const dx = x - enemy.mesh.position.x;
                const dy = y - enemy.mesh.position.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if (dist < 15) { // 吸引範圍
                    enemy.mesh.position.x += dx * 0.1;
                    enemy.mesh.position.y += dy * 0.1;
                    
                    if (dist < 2) { // 吸入範圍 (秒殺)
                        damageEnemy(enemy, 999);
                        createEffect(x, y, 'blackhole_eat');
                    }
                }
            });
        }

        function applyShockwave(x, y) {
            // 右手範圍傷害
            entities.enemies.forEach(enemy => {
                const dx = x - enemy.mesh.position.x;
                const dy = y - enemy.mesh.position.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if (dist < 10) {
                    // 推開
                    enemy.mesh.position.z -= 1; 
                    enemy.mesh.position.x -= dx * 0.1;
                    enemy.mesh.position.y -= dy * 0.1;
                    // 造成微量傷害
                    damageEnemy(enemy, 0.1); 
                }
            });
        }

        // --- 敵人系統 ---
        function spawnEnemy(isBoss) {
            const geometry = isBoss ? new THREE.IcosahedronGeometry(5, 1) : new THREE.OctahedronGeometry(1.5, 0);
            const material = new THREE.MeshBasicMaterial({ 
                color: isBoss ? 0xff0055 : 0x00ffff, 
                wireframe: true 
            });
            const mesh = new THREE.Mesh(geometry, material);
            
            // 隨機生成位置 (遠處)
            const angle = Math.random() * Math.PI * 2;
            const radius = 30 + Math.random() * 20;
            mesh.position.set(
                Math.cos(angle) * radius, 
                Math.sin(angle) * radius, 
                -50 - Math.random() * 50 // 從深處飛來
            );
            
            scene.add(mesh);
            
            entities.enemies.push({
                mesh: mesh,
                hp: isBoss ? gameState.level * 50 : gameState.level, // Boss血量多
                isBoss: isBoss,
                speed: (GAME.enemySpeedBase + gameState.level * 0.2) * (isBoss ? 0.3 : 1)
            });
        }

        function spawnBoss() {
            spawnEnemy(true);
        }

        function updateEntities(delta) {
            // 1. 子彈移動
            for (let i = entities.bullets.length - 1; i >= 0; i--) {
                const b = entities.bullets[i];
                b.mesh.position.add(b.velocity.clone().multiplyScalar(delta));
                
                // 超出範圍移除
                if (b.mesh.position.z < -100) {
                    scene.remove(b.mesh);
                    entities.bullets.splice(i, 1);
                }
            }

            // 2. 敵人 AI
            for (let i = entities.enemies.length - 1; i >= 0; i--) {
                const e = entities.enemies[i];
                
                // 飛向玩家 (0,0,0)
                const dir = new THREE.Vector3(0, 0, 10) // 目標是鏡頭後方
                    .sub(e.mesh.position).normalize();
                e.mesh.position.add(dir.multiplyScalar(e.speed * delta));
                
                // 自轉特效
                e.mesh.rotation.x += delta;
                e.mesh.rotation.y += delta;

                // 碰撞檢測 (子彈擊中)
                for (let j = entities.bullets.length - 1; j >= 0; j--) {
                    const b = entities.bullets[j];
                    const dist = e.mesh.position.distanceTo(b.mesh.position);
                    
                    // 撞到了
                    if (dist < (e.isBoss ? 5 : 2)) {
                        createEffect(b.mesh.position.x, b.mesh.position.y, 'hit');
                        damageEnemy(e, 1);
                        
                        // 移除子彈
                        scene.remove(b.mesh);
                        entities.bullets.splice(j, 1);
                    }
                }

                // 敵人撞到玩家 (扣分或結束? 這裡暫時只移除)
                if (e.mesh.position.z > 0) {
                    scene.remove(e.mesh);
                    entities.enemies.splice(i, 1);
                    // 可以在這裡加扣血邏輯
                    showMessage("DAMAGE TAKEN!", 500);
                }
            }
        }

        function damageEnemy(enemy, amount) {
            enemy.hp -= amount;
            // 閃白光特效
            enemy.mesh.material.color.setHex(0xffffff);
            setTimeout(() => {
                if(enemy.mesh) enemy.mesh.material.color.setHex(enemy.isBoss ? 0xff0055 : 0x00ffff);
            }, 50);

            if (enemy.hp <= 0) {
                createEffect(enemy.mesh.position.x, enemy.mesh.position.y, 'explosion');
                scene.remove(enemy.mesh);
                const idx = entities.enemies.indexOf(enemy);
                if (idx > -1) entities.enemies.splice(idx, 1);
                
                if(enemy.isBoss) {
                    showMessage("BOSS DESTROYED! LEVEL COMPLETE");
                    gameState.score += 1000;
                    gameState.timer = 0; // 直接過關
                }
            }
        }

        // --- 特效系統 ---
        function createEffect(x, y, type) {
            // 簡單的粒子爆炸
            const count = type === 'explosion' ? 20 : 5;
            const color = type === 'reload' ? 0x00ff00 : (type === 'explosion' ? 0xff0055 : 0xffff00);
            
            const geo = new THREE.BufferGeometry();
            const pos = [];
            for(let i=0; i<count; i++) {
                pos.push(x, y, 0);
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            const mat = new THREE.PointsMaterial({ color: color, size: 0.5, transparent: true });
            const pts = new THREE.Points(geo, mat);
            scene.add(pts);
            
            // 動畫
            let life = 1.0;
            const dirs = [];
            for(let i=0; i<count; i++) dirs.push({x:(Math.random()-0.5), y:(Math.random()-0.5)});
            
            const animateEffect = () => {
                life -= 0.05;
                if(life <= 0) {
                    scene.remove(pts);
                    return;
                }
                const positions = pts.geometry.attributes.position.array;
                for(let i=0; i<count; i++) {
                    positions[i*3] += dirs[i].x;
                    positions[i*3+1] += dirs[i].y;
                }
                pts.geometry.attributes.position.needsUpdate = true;
                pts.material.opacity = life;
                requestAnimationFrame(animateEffect);
            };
            animateEffect();
        }

    </script>
</body>
</html>
